<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Virtual QPU · Snowflurry</title><meta name="title" content="Virtual QPU · Snowflurry"/><meta property="og:title" content="Virtual QPU · Snowflurry"/><meta property="twitter:title" content="Virtual QPU · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="Snowflurry logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="basics.html">Basics</a></li><li class="is-active"><a class="tocitem" href="virtual_qpu.html">Virtual QPU</a><ul class="internal"><li><a class="tocitem" href="#QPU-Objects"><span>QPU Objects</span></a></li></ul></li><li><a class="tocitem" href="anyon_qpu.html">Real Hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../library/quantum_toolkit.html">Quantum Toolkit</a></li><li><a class="tocitem" href="../library/quantum_gates.html">Quantum Gates</a></li><li><a class="tocitem" href="../library/quantum_circuit.html">Quantum Circuits</a></li><li><a class="tocitem" href="../library/qpu.html">QPU</a></li><li><a class="tocitem" href="../library/pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="../library/viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="virtual_qpu.html">Virtual QPU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="virtual_qpu.html">Virtual QPU</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/tutorials/virtual_qpu.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-a-Circuit-on-a-Virtual-QPU"><a class="docs-heading-anchor" href="#Running-a-Circuit-on-a-Virtual-QPU">Running a Circuit on a Virtual QPU</a><a id="Running-a-Circuit-on-a-Virtual-QPU-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-Circuit-on-a-Virtual-QPU" title="Permalink"></a></h1><p>In the <a href="basics.html">previous tutorial</a>, we introduced some basic concepts of quantum computing, namely the quantum circuit and the quantum gate.</p><p>We also learned how to build and simulate a quantum circuit using <code>Snowflurry</code>. This simulation was performed on our local machine. To harness the power of quantum computing, we need to execute circuits on a Quantum Processing Unit (QPU).</p><p>In this tutorial, we will cover the steps involved in running a quantum circuit on a virtual QPU.</p><h2 id="QPU-Objects"><a class="docs-heading-anchor" href="#QPU-Objects">QPU Objects</a><a id="QPU-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#QPU-Objects" title="Permalink"></a></h2><p>Quantum processing units are represented as <a href="https://docs.julialang.org/en/v1/manual/types/#Composite-Types">composite types</a> (i.e. structs or objects) in <code>Snowflurry</code>. Every QPU type is derived from an <code>abstract type</code> called <code>AbstractQPU</code>. This allows us to write code that is agnostic of the selected quantum service. It also gives us a uniform way to retrieve metadata about the QPU, run quantum circuits on the QPU, and much more.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You should not use <code>AbstractQPU</code> directly. Instead, use a QPU type that is derived from   <code>AbstractQPU</code>. See the <a href="../library/qpu.html#Quantum-Processing-Unit">Library page</a> for a   detailed description of implemented QPU types.</p></div></div><h3 id="Virtual-QPUs"><a class="docs-heading-anchor" href="#Virtual-QPUs">Virtual QPUs</a><a id="Virtual-QPUs-1"></a><a class="docs-heading-anchor-permalink" href="#Virtual-QPUs" title="Permalink"></a></h3><p>Let&#39;s now learn how to use a QPU object. The first step is to import <code>Snowflurry</code>:</p><pre><code class="language-julia hljs">using Snowflurry</code></pre><p>We are then going to create a virtual QPU which will run on our local machine:</p><pre><code class="language-julia hljs">qpu_v = VirtualQPU()
# output
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Snowflurry.jl
</code></pre><p>We can print our QPU&#39;s metadata by calling</p><pre><code class="language-julia hljs">print(qpu_v)
# output
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Snowflurry.jl
</code></pre><p>or we can retrieve the QPU metadata in a <code>Dict{String,String}</code> format using the following command:</p><pre><code class="language-julia hljs">get_metadata(qpu_v)
# output
Dict{String, Union{Int64, Vector{Int64}, Vector{Tuple{Int64, Int64}}, String}} with 2 entries:
  &quot;developers&quot; =&gt; &quot;Anyon Systems Inc.&quot;
  &quot;package&quot;    =&gt; &quot;Snowflurry.jl&quot;

</code></pre><p>Now, let&#39;s create a circuit that generates a Bell state, as explained in the <a href="basics.html">previous tutorial</a>:</p><pre><code class="language-julia hljs">c = QuantumCircuit(qubit_count = 2)
push!(c, hadamard(1), control_x(1, 2))
# output
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──</code></pre><p>Although we&#39;ve created a circuit that produces a Bell pair, we need to <em>measure</em> our qubits in order to collect results. In Snowflurry, we use <a href="../library/quantum_toolkit.html#Snowflurry.Readout"><code>Readout</code></a> instructions to indicate that a measurement must be taken. These instructions can be built using the <a href="../library/quantum_toolkit.html#Snowflurry.readout"><code>readout()</code></a> helper function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Measurements are always performed in the <span>$Z$</span> basis   (also known as the computational basis).</p></div></div><p>Let&#39;s add <a href="../library/quantum_toolkit.html#Snowflurry.Readout"><code>Readout</code></a> instructions to each qubit:</p><pre><code class="language-julia hljs">push!(c, readout(1, 1), readout(2, 2))
# output
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*────✲───────
            |            
q[2]:───────X─────────✲──</code></pre><p>Here, we see that a <code>readout</code> instruction can be added to a circuit like any other gate. Each readout instruction needs two parameters. The first is the index of the qubit to measure. The second is the index of the classical bit in which the result will be stored. For example, calling <code>readout(2, 4)</code> generates an <code>instruction</code> that tells the QPU to measure qubit 2 and store the result in classical bit 4. In the previous circuit, the first readout instruction indicates that qubit 1 is measured and that the result is written to bit 1. The second readout instruction tells the QPU to repeat this process for qubit 2 and bit 2.</p><p>In Snowflurry, <code>readout</code> instructions can involve the measurement of any qubit and the storing of results in any bit. However, there are some restrictions:</p><ul><li>Every <code>readout</code> instruction must be the final instruction that is applied to the target  qubit.<ul><li>We plan to lift this restriction in future versions of Snowflurry.</li></ul></li><li>Distinct <code>readout</code> instructions must write to distinct result bits.</li></ul><p>Now that we&#39;ve added <code>readout</code> instructions to our circuit, let&#39;s run it on the virtual QPU for 100 shots:</p><pre><code class="language-julia hljs">shots_count = 100
result, qpu_time = run_job(qpu_v, c, shots_count)</code></pre><p>The <code>result</code> object is a <code>Dict{String, Int64}</code> that indicates how many times each state was measured on the QPU:</p><pre><code class="language-julia hljs">print(result)

Dict(&quot;00&quot; =&gt; 53, &quot;11&quot; =&gt; 47)</code></pre><p>Here, we see that the classical bits were set to &quot;00&quot; in 53 of the 100 shots while they were set to &quot;11&quot; in the other 47 shots. <strong>Only non-zero entries are stored in the <code>result</code> object.</strong></p><div class="admonition is-info"><header class="admonition-header">Qubit and bit ordering convention</header><div class="admonition-body"><p>In Snowflurry, the leftmost qubit in a state is associated with the first qubit in a   circuit. For example, if a circuit is in state <span>$|01\rangle$</span>, it means that qubit 1 is   in state <span>$|0\rangle$</span> and qubit 2 is in state <span>$|1\rangle$</span>. The same convention is   used for classical bits.</p></div></div><div class="admonition is-info"><header class="admonition-header">Statistical uncertainty</header><div class="admonition-body"><p>The reason why the number of &quot;00&quot; and &quot;11&quot; bit strings is not equal is due to the fact   that the <code>VirtualQPU</code> tries to mimic the statistical nature of real QPUs. The   statistical uncertainty can be reduced by increasing the <code>shots_count</code> in the   simulation. A simulation with more shots should provide stronger indications that the   probability of obtaining &quot;00&quot; and &quot;11&quot; is equal.</p></div></div><p>The virtual QPU currently mimics an ideal hardware with no errors. The probability of measuring states <span>$\left|01\right\rangle$</span> or <span>$\left|10\right\rangle$</span> in the previous example was, therefore, zero. Noise models should be added in future versions of <code>Snowflurry</code> for noise sources such as crosstalk, thermal noise, and more.</p><p>In the <a href="anyon_qpu.html">next tutorial</a>, we will show how to submit a job to real quantum processing hardware.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="basics.html">« Basics</a><a class="docs-footer-nextpage" href="anyon_qpu.html">Real Hardware »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 8 November 2024 17:49">Friday 8 November 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
