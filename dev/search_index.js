var documenterSearchIndex = {"docs":
[{"location":"library/viz.html#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"library/viz.html","page":"Visualization","title":"Visualization","text":"The SnowflurryPlots package provides multiple visualization tools for Snowflurry.jl. Please see the documentation of SnowflurryPlots for more details. ","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Asynchronous-jobs","page":"Asynchronous Jobs","title":"Asynchronous jobs","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In this tutorial, we will learn how to run jobs asynchronously using Julia tasks. The use of asynchronous jobs allows other computations to continue while waiting for results from the QPU.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Julia-tasks","page":"Asynchronous Jobs","title":"Julia tasks","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Practical applications of quantum computing typically involve both classical and quantum computation. A quantum processor is a hardware accelerator in this paradigm. It may therefore be desirable to continue some of the classical computations while the program waits for the quantum hardware to complete its tasks. This is an example of asynchronous programming. We recommend that you consult Julia's page on asynchronous programming if you are unfamiliar with this concept.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In Snowflurry, the function that communicates with a quantum processor will yield execution while it waits for a response from the quantum computer. This allows other computations to continue while the quantum computer is running our job.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Code","page":"Asynchronous Jobs","title":"Code","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"To provide maximum flexibility, Snowflurry does not impose any restrictions on how you parallelize your code. We cannot know what will be best for your code. That is up to you!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"As shown in the Running a Circuit on a Real Hardware tutorial, we will start by importing Snowflurry, building our circuit, and defining our QPU:","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"using Snowflurry\n\ncircuit = QuantumCircuit(qubit_count = 2, instructions = [\n    hadamard(1),\n    control_x(1, 2),\n    readout(1, 1),\n    readout(2, 2),\n])\n\nuser = ENV[\"THUNDERHEAD_USER\"]\ntoken = ENV[\"THUNDERHEAD_API_TOKEN\"]\nhost = ENV[\"THUNDERHEAD_HOST\"]\nproject = ENV[\"THUNDERHEAD_PROJECT_ID\"]\nrealm = ENV[\"THUNDERHEAD_REALM\"]\n\nqpu = AnyonYukonQPU(host = host, user = user, access_token = token, project_id = project, realm = realm)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Next, we are going to define and schedule our task:","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"shot_count = 200\ntask = Task(() -> run_job(qpu, circuit, shot_count))\nschedule(task)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"warning: Warning\nDo not forget the last line in the previous code block! It is important to schedule the task, otherwise it will not start!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"We then need to yield execution of the current thread to the newly scheduled task:","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"yieldto(task)\n\n# Simulate work by calculating the nth Fibonacci number slowly\nfunction fibonacci(n)\n  if n <= 2\n    return 1\n  end\n  return fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nfibonacci(30)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"This ensures that the scheduler starts the task. Otherwise, it might take a while for our task to start and for our jobs to be submitted to the quantum computer! Our program can also perform other computations after yielding. We can then fetch the results from our task:","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"result = fetch(task)\nprintln(result)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"The full code is available at tutorials/asynchronous_jobs.jl.","category":"page"},{"location":"tutorials/virtual_qpu.html#Running-a-Circuit-on-a-Virtual-QPU","page":"Virtual QPU","title":"Running a Circuit on a Virtual QPU","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the previous tutorial, we introduced some basic concepts of quantum computing, namely the quantum circuit and the quantum gate.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"We also learned how to build and simulate a quantum circuit using Snowflurry. This simulation was performed on our local machine. To harness the power of quantum computing, we need to execute circuits on a Quantum Processing Unit (QPU).","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In this tutorial, we will cover the steps involved in running a quantum circuit on a virtual QPU.","category":"page"},{"location":"tutorials/virtual_qpu.html#QPU-Objects","page":"Virtual QPU","title":"QPU Objects","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Quantum processing units are represented as composite types (i.e. structs or objects) in Snowflurry. Every QPU type is derived from an abstract type called AbstractQPU. This allows us to write code that is agnostic of the selected quantum service. It also gives us a uniform way to retrieve metadata about the QPU, run quantum circuits on the QPU, and much more.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"warning: Warning\nYou should not use AbstractQPU directly. Instead, use a QPU type that is derived from   AbstractQPU. See the Library page for a   detailed description of implemented QPU types.","category":"page"},{"location":"tutorials/virtual_qpu.html#Virtual-QPUs","page":"Virtual QPU","title":"Virtual QPUs","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Let's now learn how to use a QPU object. The first step is to import Snowflurry:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"using Snowflurry","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"We are then going to create a virtual QPU which will run on our local machine:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"qpu_v = VirtualQPU()\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"We can print our QPU's metadata by calling","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(qpu_v)\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"or we can retrieve the QPU metadata in a Dict{String,String} format using the following command:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"get_metadata(qpu_v)\n# output\nDict{String, Union{Int64, Vector{Int64}, Vector{Tuple{Int64, Int64}}, String}} with 2 entries:\n  \"developers\" => \"Anyon Systems Inc.\"\n  \"package\"    => \"Snowflurry.jl\"\n\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now, let's create a circuit that generates a Bell state, as explained in the previous tutorial:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"c = QuantumCircuit(qubit_count = 2)\npush!(c, hadamard(1), control_x(1, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Although we've created a circuit that produces a Bell pair, we need to measure our qubits in order to collect results. In Snowflurry, we use Readout instructions to indicate that a measurement must be taken. These instructions can be built using the readout() helper function.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Note\nMeasurements are always performed in the Z basis   (also known as the computational basis).","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Let's add Readout instructions to each qubit:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"push!(c, readout(1, 1), readout(2, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Here, we see that a readout instruction can be added to a circuit like any other gate. Each readout instruction needs two parameters. The first is the index of the qubit to measure. The second is the index of the classical bit in which the result will be stored. For example, calling readout(2, 4) generates an instruction that tells the QPU to measure qubit 2 and store the result in classical bit 4. In the previous circuit, the first readout instruction indicates that qubit 1 is measured and that the result is written to bit 1. The second readout instruction tells the QPU to repeat this process for qubit 2 and bit 2.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In Snowflurry, readout instructions can involve the measurement of any qubit and the storing of results in any bit. However, there are some restrictions:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Every readout instruction must be the final instruction that is applied to the target  qubit.\nWe plan to lift this restriction in future versions of Snowflurry.\nDistinct readout instructions must write to distinct result bits.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now that we've added readout instructions to our circuit, let's run it on the virtual QPU for 100 shots:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"shots_count = 100\nresult, qpu_time = run_job(qpu_v, c, shots_count)","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"The result object is a Dict{String, Int64} that indicates how many times each state was measured on the QPU:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(result)\n\nDict(\"00\" => 53, \"11\" => 47)","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Here, we see that the classical bits were set to \"00\" in 53 of the 100 shots while they were set to \"11\" in the other 47 shots. Only non-zero entries are stored in the result object.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Qubit and bit ordering convention\nIn Snowflurry, the leftmost qubit in a state is associated with the first qubit in a   circuit. For example, if a circuit is in state 01rangle, it means that qubit 1 is   in state 0rangle and qubit 2 is in state 1rangle. The same convention is   used for classical bits.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Statistical uncertainty\nThe reason why the number of \"00\" and \"11\" bit strings is not equal is due to the fact   that the VirtualQPU tries to mimic the statistical nature of real QPUs. The   statistical uncertainty can be reduced by increasing the shots_count in the   simulation. A simulation with more shots should provide stronger indications that the   probability of obtaining \"00\" and \"11\" is equal.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"The virtual QPU currently mimics an ideal hardware with no errors. The probability of measuring states left01rightrangle or left10rightrangle in the previous example was, therefore, zero. Noise models should be added in future versions of Snowflurry for noise sources such as crosstalk, thermal noise, and more.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the next tutorial, we will show how to submit a job to real quantum processing hardware.","category":"page"},{"location":"development.html#Snowflurry-development","page":"Developing","title":"Snowflurry development","text":"","category":"section"},{"location":"development.html#Installing-Snowflurry-for-local-development","page":"Developing","title":"Installing Snowflurry for local development","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"When developing Snowflurry, you must ensure that you are using a local copy of Snowflurry, not the latest released version. The easiest way to achieve that is to set the project to the local directory.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you are starting a new instance of Julia, then you can activate the Snowflurry project with","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"or, if you are inside a script or REPL, you can use","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If the current directory is not the Snowflurry project, replace . with the Snowflurry project path.","category":"page"},{"location":"development.html#Running-tests","page":"Developing","title":"Running tests","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a Julia REPL in the current project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"and run the tests","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.test()","category":"page"},{"location":"development.html#Build-the-documentation","page":"Developing","title":"Build the documentation","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"Open a Julia REPL using the docs project:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=./docs","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If it is your first time building the docs, you need to instantiate the Julia project and add the Snowflurry project as a development dependency:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.develop(PackageSpec(path=pwd()))\nPkg.instantiate()","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"In other words, Julia's package manager must add the version of Snowflurry which is located in the current working directory, pwd(), not the one which is registered at JuliaHub.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"At this point, the project status should be similar to the one below:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Pkg.status()\n\n# output\n      Status `<pwd()>/Snowflurry.jl/docs/Project.toml`\n  [e30172f5] Documenter v0.27.24\n  [cd3eb016] HTTP v1.7.4\n  [682c06a0] JSON v0.21.4\n  [7bd9edc1] Snowflurry v0.1.0 `<pwd()>/Snowflurry.jl`\n  [90137ffa] StaticArrays v1.5.21\n  [2913bbd2] StatsBase v0.33.21\n  [de0858da] Printf","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The versions might be slightly different, but what is important is that the Status line refers to the docs/Project.toml and that Snowflurry refers to <pwd()>/Snowflurry.jl.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can then run the following to build the documentation website:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"include(\"./docs/make.jl\")","category":"page"},{"location":"development.html#Determine-the-coverage-locally","page":"Developing","title":"Determine the coverage locally","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you haven't already, instantiate the project with Julia's package manager:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.Instantiate()'","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can determine the coverage by executing the following command from the project root directory:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. coverage.jl","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The script returns the number of covered and total lines. An example of the script's output is shown below:","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Covered lines: 1373\nTotal lines: 1383\nCoverage percentage: 0.9927693420101229","category":"page"},{"location":"library/qpu.html#Quantum-Processing-Unit","page":"QPU","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library/qpu.html#Snowflurry.AnyonYukonQPU","page":"QPU","title":"Snowflurry.AnyonYukonQPU","text":"AnyonYukonQPU <: AbstractQPU\n\nA data structure that describes an Anyon System QPU of the Yukon generation.  The QPU contains 6 qubits in a linear arrangement (see LineConnectivity). \n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to limit the rate of job status requests.\nproject_id              ::String – Used to identify the project for the jobs that are sent to the QPU.\nrealm                   ::String – Optional: Used to identify the host server realm for the submission of requests.\n\nExample\n\njulia>  qpu = AnyonYukonQPU(\n            host = \"http://example.anyonsys.com\",\n            user = \"test_user\",\n            access_token = \"not_a_real_access_token\",\n            project_id = \"test-project\",\n            realm = \"test-realm\"\n        )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6 \n   connectivity_type:  linear\n   realm:         test-realm\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.AnyonYamaskaQPU","page":"QPU","title":"Snowflurry.AnyonYamaskaQPU","text":"AnyonYamaskaQPU <: AbstractQPU\n\nA data structure that describes an Anyon System QPU of the Yamaska generation.  The QPU contains 24 qubits in a 2D lattice arrangement (see LatticeConnectivity).\n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to limit the rate of job status requests.\nproject_id              ::String – Used to identify the project for the jobs that are sent to the QPU.\nrealm                   ::String – Optional: Used to identify the host server realm for the submission of requests.\n\nExample\n\njulia>  qpu = AnyonYamaskaQPU(\n            host = \"http://example.anyonsys.com\",\n            user = \"test_user\",\n            access_token = \"not_a_real_access_token\",\n            project_id = \"test-project\",\n            realm = \"test-realm\"\n        )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yamaska\n   serial_number: ANYK202301\n   project_id:    test-project\n   qubit_count:   24 \n   connectivity_type:  2D-lattice\n   realm:         test-realm\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.VirtualQPU","page":"QPU","title":"Snowflurry.VirtualQPU","text":"VirtualQPU\n\nThe data structure for a quantum simulator.  \n\nExample\n\njulia> qpu = VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.Client","page":"QPU","title":"Snowflurry.Client","text":"Client\n\nA data structure that represents a client for connection to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\nrealm::String – Optional: Used to identify the host server realm for the submission of requests.\n\nExample\n\njulia> c = Client(\n            host = \"http://example.anyonsys.com\",\n            user = \"test_user\",\n            access_token = \"not_a_real_access_token\",\n            realm = \"test_realm\"\n        )\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n   realm:        test_realm \n \n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.get_client","page":"QPU","title":"Snowflurry.get_client","text":"get_client(qpu_service::UnionAnyonQPU)\n\nReturns the client that is associated with the qpu_service.\n\nExample\n\njulia> qpu = AnyonYukonQPU(\n           host = \"http://example.anyonsys.com\",\n           user = \"test_user\",\n           access_token = \"not_a_real_access_token\",\n           project_id = \"test-project\",\n           realm = \"test-realm\"\n       )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6\n   connectivity_type:  linear\n   realm:         test-realm\n\n\njulia> get_client(qpu)\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n   realm:        test-realm \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_project_id","page":"QPU","title":"Snowflurry.get_project_id","text":"get_project_id(qpu_service::UnionAnyonQPU)\n\nReturns the project ID that is associated with the qpu_service.\n\nExample\n\njulia> qpu = AnyonYukonQPU(\n           host = \"http://example.anyonsys.com\",\n           user = \"test_user\",\n           access_token = \"not_a_real_access_token\",\n           project_id = \"test-project\",\n           realm = \"test-realm\"\n       )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6\n   connectivity_type:  linear\n   realm:         test-realm\n\n\njulia> get_project_id(qpu)\n\"test-project\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_host","page":"QPU","title":"Snowflurry.get_host","text":"get_host(Client)\n\nReturns the host URL of a Client for connection to a QPU service.  \n\nExample\n\njulia> c = Client(\n            host = \"http://example.anyonsys.com\",\n            user = \"test_user\",\n            access_token = \"not_a_real_access_token\"\n        );\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.submit_job","page":"QPU","title":"Snowflurry.submit_job","text":"submit_job(\n    client::Client,\n    circuit::QuantumCircuit,\n    shot_count::Integer,\n    project_id::String,\n    machine_name::String\n)\n\nUse a client to submit a circuit to a QPU service on the host server.  The QPU service is specified by the machine_name. The number of circuit executions is specified by shot_count. \n\nReturns the circuit ID, which can then be used when calling get_status.\n\nExample\n\njulia> circuit = QuantumCircuit(\n            qubit_count = 3,\n            instructions = [sigma_x(3), control_z(2, 1),\n            readout(1, 1)]\n        );\n\njulia> submit_job(client, circuit, 100, \"project_id\", \"yukon\")\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.Status","page":"QPU","title":"Snowflurry.Status","text":"Status\n\nA data structure that stores the status of a quantum computation.  \n\nFields\n\ntype::String – One of the declared types, e.g.:\n\"QUEUED\"   : Computation in the queue.\n\"RUNNING\"  : Computation being processed.\n\"FAILED\"   : QPU service has returned an error message.\n\"SUCCEEDED\": Computation has succeeded, results are available.\n\"CANCELLED\": Computation was terminated before completion.\nmessage::String – Optional: Message providing additional details about the computation   status.\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.get_status_type","page":"QPU","title":"Snowflurry.get_status_type","text":"get_status_type(s::Status)::String\n\nReturns the type associated with the Status of a quantum computation.\n\nSee Status for more details about possible type strings.\n\nExamples\n\njulia> get_status_type(Status(type = \"SUCCEEDED\"))\n\"SUCCEEDED\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_status_message","page":"QPU","title":"Snowflurry.get_status_message","text":"get_status_message(s::Status)::String\n\nReturns the message associated with the Status of a quantum computation.\n\nExamples\n\njulia> get_status_message(Status(type = \"FAILED\", message = \"something failed\"))\n\"something failed\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_status","page":"QPU","title":"Snowflurry.get_status","text":"get_status(client::Client,circuitID::String)::Tuple{Status,Dict{String,Int}}\n\nObtain the status of a circuit computation which uses a client for connection to a QPU service. See Status for more details about possible statuses.\n\nIn the case of status[\"type\"]==\"FAILED\", the server error is contained in status[\"message\"].\n\nIn the case of status[\"type\"]==\"SUCCEEDED\", the second element in the return tuple is  the histogram of the job results, as computed on the QPU, and the third element is the  job's execution time on the QPU, in milliseconds. \n\nExample\n\njulia> circuit = QuantumCircuit(\n            qubit_count = 3,\n            instructions = [sigma_x(3), control_z(2, 1),\n            readout(1, 1)]\n        );\n\njulia> jobID = submit_job(submit_job_client, circuit, 100, \"project_id\", \"yukon\")\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(submit_job_client, jobID)\n(Status: SUCCEEDED\n, Dict(\"001\" => 100), 542)\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.read_response_body","page":"QPU","title":"Snowflurry.read_response_body","text":"read_response_body(body::Base.CodeUnits{UInt8,String})::String\n\nReturns a String from Unicode code units.\n\nSee the Julia documentation for more details about code units.\n\nExample\n\njulia> string = \"my string\"\n\"my string\"\n\njulia> body = codeunits(string)\n9-element Base.CodeUnits{UInt8, String}:\n 0x6d\n 0x79\n 0x20\n 0x73\n 0x74\n 0x72\n 0x69\n 0x6e\n 0x67\n\njulia> read_response_body(body)\n\"my string\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.run_job","page":"QPU","title":"Snowflurry.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit, shot_count::Integer)\n\nExecute a circuit on a QPU simulator. The number of circuit executions is specified by shot_count.\n\nReturns a histogram of the circuit measurement outcomes as prescribed by the Readout instructions in the circuit.\n\nExample\n\njulia> qpu = VirtualQPU();\n\njulia> circuit = QuantumCircuit(\n            qubit_count = 3,\n            instructions = [\n                sigma_x(3),\n                control_z(2, 1),\n                readout(1, 1),\n                readout(2, 2),\n                readout(3, 3)\n            ]\n        );\n\njulia> run_job(qpu, circuit, 100)\n(Dict(\"001\" => 100), 147)\n\n\n\n\n\n\nrun_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit, shot_count::Integer)\n\nSubmit a circuit to a QPU service for execution. The function does not perform the standard transpilation as in transpile_and_run_job. The number of circuit executions is specified by shot_count.\n\nReturns a histogram of the circuit measurement outcomes along with the  simulation's execution time (in milliseconds) or an error message.\n\nIf the circuit is invalid, it is not sent to the host and an error is thrown. The circuit can be invalid for the following reasons:\n\nThe circuit contains no Readout instructions (see   CircuitContainsAReadoutTranspiler).\nMultiple Readout instructions have the same destination bits (see   ReadoutsDoNotConflictTranspiler).\nThe Readout instructions are not the last operation on each qubit where a readout is   present (see ReadoutsAreFinalInstructionsTranspiler).\nThe circuit contains a Controlled gate that operates on more than two qubits (see   UnsupportedGatesTranspiler).\n\nExample\n\njulia> qpu = AnyonYukonQPU(client, \"project_id\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    project_id\n   qubit_count:   6 \n   connectivity_type:  linear\n   realm:         test-realm\n\njulia> circuit = QuantumCircuit(\n            qubit_count = 3,\n            instructions = [sigma_x(3), control_z(2, 1), readout(1, 1)]\n        );\n\njulia> run_job(qpu, circuit, 100)\n(Dict(\"001\" => 100), 542)\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.transpile_and_run_job","page":"QPU","title":"Snowflurry.transpile_and_run_job","text":"transpile_and_run_job(\n    qpu::VirtualQPU,\n    circuit::QuantumCircuit,\n    shot_count::Integer;\n    transpiler::Transpiler = get_transpiler(qpu)\n)\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a keyword argument. The transpiled circuit is then executed on a QPU simulator, where the number of circuit executions is specified by shot_count.\n\nReturns the histogram of the circuit measurement outcomes, or an error message.\n\nExample\n\njulia> qpu = VirtualQPU();\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 3,\n                    instructions = [\n                        sigma_x(3),\n                        control_z(2, 1),\n                        readout(1, 1),\n                        readout(2, 2),\n                        readout(3, 3)\n                    ]);\n\njulia> transpile_and_run_job(qpu, circuit,100)\n(Dict(\"001\" => 100), 132)\n\n\n\n\n\n\ntranspile_and_run_job(\n    qpu::UnionAnyonQPU,\n    circuit::QuantumCircuit,\n    shot_count::Integer;\n    transpiler::Transpiler = get_transpiler(qpu)\n)\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a keyword argument. The transpiled circuit is then submitted for execution on an Anyon QPU. The number of circuit executions is specified by shot_count.\n\nReturns the histogram of the circuit measurement outcomes along with the job's  execution time on the QPU (in milliseconds), or an error message.\n\nExample\n\njulia> qpu = AnyonYukonQPU(client_anyon, \"project_id\");\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 3,\n                    instructions = [\n                        sigma_x(3),\n                        control_z(2, 1),\n                        readout(3, 3)\n                    ]);\n\njulia> transpile_and_run_job(qpu, circuit, 100)\n(Dict(\"001\" => 100), 542)\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_transpiler","page":"QPU","title":"Snowflurry.get_transpiler","text":"get_transpiler(qpu::AbstractQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu = AnyonYukonQPU(client, \"project_id\");\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CircuitContainsAReadoutTranspiler(), ReadoutsDoNotConflictTranspiler(), UnsupportedGatesTranspiler(), DecomposeSingleTargetSingleControlGatesTranspiler(), CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), CastRootZZToZ90AndCZGateTranspiler(), SwapQubitsForAdjacencyTranspiler(LineConnectivity{6}\n1──2──3──4──5──6\n), CastSwapToCZGateTranspiler()  …  SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6), ReadoutsAreFinalInstructionsTranspiler(), RejectNonNativeInstructionsTranspiler(LineConnectivity{6}\n1──2──3──4──5──6\n, DataType[Snowflurry.Identity, Snowflurry.PhaseShift, Snowflurry.Pi8, Snowflurry.Pi8Dagger, Snowflurry.SigmaX, Snowflurry.SigmaY, Snowflurry.SigmaZ, Snowflurry.X90, Snowflurry.XM90, Snowflurry.Y90, Snowflurry.YM90, Snowflurry.Z90, Snowflurry.ZM90, Snowflurry.ControlZ]), RejectGatesOnExcludedPositionsTranspiler(LineConnectivity{6}\n1──2──3──4──5──6\n), RejectGatesOnExcludedConnectionsTranspiler(LineConnectivity{6}\n1──2──3──4──5──6\n)])\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.AllToAllConnectivity","page":"QPU","title":"Snowflurry.AllToAllConnectivity","text":"AllToAllConnectivity <:AbstractConnectivity\n\nA data structure which describes the all-to-all qubit connectivity of an Anyon Systems QPU. This connectivity type is encountered in simulated QPUs such as the VirtualQPU.\n\nExample\n\njulia> connectivity = AllToAllConnectivity()\nAllToAllConnectivity()\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.LineConnectivity","page":"QPU","title":"Snowflurry.LineConnectivity","text":"LineConnectivity <:AbstractConnectivity\n\nA data structure which describes the linear qubit connectivity of an Anyon System's QPU. This connectivity type is encountered in QPUs such as the AnyonYukonQPU.\n\nFields\n\ndimension         ::Int – Number of qubits for this connectivity.\nexcluded_positions::Vector{Int} – Optional: List of qubits on the connectivity which                                      are disabled and cannot perform operations. Elements                                      in Vector must be unique.\nexcluded_connections::Vector{Tuple{Int, Int}} – Optional: List of connections between                                                    qubits which are disabled and cannot                                                    perform 2-qubit gates. Elements in                                                    Vector must be unique. Each                                                    connection is provided as a Tuple of                                                    qubit indices.\n\nnote: Note\nEvery excluded connection is sorted in ascending order (i.e. connection (2, 1) will be changed to (1, 2)).\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\njulia> connectivity = LineConnectivity(6, [1,2,3], [(3, 2), (3, 4)])\nLineConnectivity{6}\n1──2──3──4──5──6\nexcluded positions: [1, 2, 3]\nexcluded connections: [(2, 3), (3, 4)]\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.LatticeConnectivity","page":"QPU","title":"Snowflurry.LatticeConnectivity","text":"LatticeConnectivity <:AbstractConnectivity\n\nA data structure which describes the two-dimensional lattice qubit connectivity of an Anyon System's QPU. This connectivity type is encountered in QPUs such as the AnyonYamaskaQPU.\n\nFields\n\nqubits_per_printout_line::Vector{Int} – Number of qubits in each line when constructing                                            the printout.\ndimensions              ::Vector{Int} – Number of rows and columns (turned 45° in the                                            printout).\nexcluded_positions      ::Vector{Int} – Optional: List of qubits on the connectivity                                            which are disabled and cannot perform                                            operations. Elements in Vector must be                                            unique.\nexcluded_connections::Vector{Tuple{Int, Int}} – Optional: List of connections between                                                    qubits which are disabled and cannot                                                    perform 2-qubit gates. Elements in                                                    Vector must be unique. Each                                                    connection is provided as a Tuple of                                                    qubit indices.\n\nExample\n\nThe following lattice has 3 rows, where each row has 4 elements. The rows contain qubits  [1, 2, 3, 4], [ 5, 6, 7, 8], and [9, 10, 11, 12].\n\nThe corresponding qubits_per_printout_line field is [1, 3, 3, 3, 2]. It contains the number of qubits in each line of the printed representation.\n\njulia> connectivity = LatticeConnectivity(3, 4)\nLatticeConnectivity{3,4}\n        1 \n        | \n  9 ──  5 ──  2 \n        |     | \n       10 ──  6 ──  3 \n              |     | \n             11 ──  7 ──  4 \n                    |     | \n                   12 ──  8 \n\n\n\nLattices of arbitrary dimensions can be built:\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 \n              | \n        9 ──  5 ──  2 \n        |     |     | \n 17 ── 13 ── 10 ──  6 ──  3 \n  |     |     |     |     | \n 21 ── 18 ── 14 ── 11 ──  7 ──  4 \n        |     |     |     |     | \n       22 ── 19 ── 15 ── 12 ──  8 \n              |     |     | \n             23 ── 20 ── 16 \n                    | \n                   24 \n\nOptionally, lattices with excluded positions can be defined:\n\njulia> connectivity = LatticeConnectivity(3, 4, [1, 5, 9])\nLatticeConnectivity{3,4}\n        1 \n        | \n  9 ──  5 ──  2 \n        |     | \n       10 ──  6 ──  3 \n              |     | \n             11 ──  7 ──  4 \n                    |     | \n                   12 ──  8 \n\nexcluded positions: [1, 5, 9]\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.get_excluded_connections","page":"QPU","title":"Snowflurry.get_excluded_connections","text":"get_excluded_connections(\n    connectivity::Union{LineConnectivity,LatticeConnectivity}\n)::ExcludedConnections\n\nReturns the list of excluded_connections for the connectivity.\n\n\n\n\n\nget_excluded_connections(connectivity::AbstractConnectivity)::Vector{Tuple{Int, Int}}\n\nThrows a NotImplementedError.\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_excluded_positions","page":"QPU","title":"Snowflurry.get_excluded_positions","text":"get_excluded_positions(\n    c::Union{LineConnectivity,LatticeConnectivity}\n)::Vector{Tuple{Int, Int}}\n\nReturns the list of excluded_positions for the connectivity.\n\nExample\n\njulia> get_excluded_positions(LatticeConnectivity(3, 4, [1, 3]))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n\nget_excluded_positions(connectivity::AbstractConnectivity)::Vector{Tuple{Int, Int}}\n\nThrows a NotImplementedError.\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.path_search","page":"QPU","title":"Snowflurry.path_search","text":"path_search(\n    origin::Int,\n    target::Int,\n    connectivity::AbstractConnectivity,\n    excluded::Vector{Int} = Vector{Int}([])\n)::Vector{Int}\n\nFind the shortest path between origin and target qubits in terms of  Manhattan distance. The path is found for any connectivity::AbstractConnectivity using the Breadth-first search algorithm. Positions that are specified in the  excluded optional argument are avoided. If no path exists, returns an empty Vector{Int}.\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> path = path_search(2, 5, connectivity)\n4-element Vector{Int64}:\n 5\n 4\n 3\n 2\n\n\nFor LatticeConnectivity, the print_connectivity() method is used to visualize the path. The qubits along the path between origin and target are marked with ( )\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 \n              | \n        9 ──  5 ──  2 \n        |     |     | \n 17 ── 13 ── 10 ──  6 ──  3 \n  |     |     |     |     | \n 21 ── 18 ── 14 ── 11 ──  7 ──  4 \n        |     |     |     |     | \n       22 ── 19 ── 15 ── 12 ──  8 \n              |     |     | \n             23 ── 20 ── 16 \n                    | \n                   24 \n\n\njulia> path = path_search(3, 24, connectivity)\n6-element Vector{Int64}:\n 24\n 20\n 16\n 12\n  7\n  3\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_adjacency_list","page":"QPU","title":"Snowflurry.get_adjacency_list","text":"get_adjacency_list(connectivity::AbstractConnectivity)::Dict{Int,Vector{Int}}\n\nGiven an object of type AbstractConnectivity, get_adjacency_list returns a Dict where each key is a qubit index. Every dictionary value is a Vector that lists all the qubits which are adjacent on the connectivity to the qubit key. Positions in connectivity.excluded_positions are not included as keys nor values.\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> get_adjacency_list(connectivity)\nDict{Int64, Vector{Int64}} with 6 entries:\n  5 => [4, 6]\n  4 => [3, 5]\n  6 => [5]\n  2 => [1, 3]\n  3 => [2, 4]\n  1 => [2]\n\njulia> connectivity = LatticeConnectivity(3, 4)\nLatticeConnectivity{3,4}\n        1 \n        | \n  9 ──  5 ──  2 \n        |     | \n       10 ──  6 ──  3 \n              |     | \n             11 ──  7 ──  4 \n                    |     | \n                   12 ──  8 \n  \njulia> get_adjacency_list(connectivity)\nDict{Int64, Vector{Int64}} with 12 entries:\n  5  => [1, 10, 9, 2]\n  12 => [7, 8]\n  8  => [4, 12]\n  1  => [5]\n  6  => [2, 11, 10, 3]\n  11 => [6, 7]\n  9  => [5]\n  3  => [7, 6]\n  7  => [3, 12, 11, 4]\n  4  => [8, 7]\n  2  => [6, 5]\n  10 => [5, 6]\n\n\nnote: Note\nThe get_adjacency_list function cannot be used for AllToAllConnectivity since this type of connectivity places no upper bound on the number of qubits and all qubits connect to each other by definition. A finite list of adjacent qubits thus cannot be constructed. \n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_qubits_distance","page":"QPU","title":"Snowflurry.get_qubits_distance","text":"get_qubits_distance(target_1::Int, target_2::Int, ::AbstractConnectivity)\n\nFind the length of the shortest path between target qubits in terms of the Manhattan distance. The function uses the Breadth-first search algorithm to determine the path length for any connectivity::AbstractConnectivity.\n\nExample\n\njulia>  connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> get_qubits_distance(2, 5, connectivity)\n3\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 \n              | \n        9 ──  5 ──  2 \n        |     |     | \n 17 ── 13 ── 10 ──  6 ──  3 \n  |     |     |     |     | \n 21 ── 18 ── 14 ── 11 ──  7 ──  4 \n        |     |     |     |     | \n       22 ── 19 ── 15 ── 12 ──  8 \n              |     |     | \n             23 ── 20 ── 16 \n                    | \n                   24 \n\n\njulia> get_qubits_distance(3, 24, connectivity)\n5\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.is_native_instruction","page":"QPU","title":"Snowflurry.is_native_instruction","text":"is_native_instruction(\n    gate::Union{Gate},\n    connectivity::Union{LineConnectivity,LatticeConnectivity},\n    native_gates::Vector{DataType} = set_of_native_gates,\n)::Bool\n\nReturns true if the gate is a native instruction for the connectivity and the list of possible native_gates. The native gates for the Anyon QPUs are used by default.\n\nA native instruction is defined as an instruction that is in native_gates and that satisifies the connectivity. It does not check to determine if the gate is placed at the excluded_positions or excluded_connections of the connectivity. The gate must operate on less than three qubits.\n\nExample\n\njulia> connectivity = LineConnectivity(3)\nLineConnectivity{3}\n1──2──3\n\n\njulia> is_native_instruction(control_z(1, 2), connectivity)\ntrue\n\njulia> is_native_instruction(control_z(1, 3), connectivity)\nfalse\n\njulia> is_native_instruction(control_x(1, 2), connectivity)\nfalse\n\njulia> is_native_instruction(control_x(1, 2), connectivity, [Snowflurry.ControlX])\ntrue\n\njulia> is_native_instruction(toffoli(1, 2, 3), connectivity, [Snowflurry.Toffoli])\nfalse\n\n\n\n\n\n\nis_native_instruction(\n    readout::Readout,\n    connectivity::Union{LineConnectivity,LatticeConnectivity},\n    native_gates::Vector{DataType} = set_of_native_gates,\n)::Bool\n\nReturns true if the readout satisfies the connectivity.\n\nIt does not check to determine if the gate is placed at the excluded_positions of the connectivity.\n\nExample\n\njulia> connectivity = LineConnectivity(3)\nLineConnectivity{3}\n1──2──3\n\n\njulia> is_native_instruction(readout(2, 2), connectivity)\ntrue\n\njulia> is_native_instruction(readout(4, 4), connectivity)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.is_native_circuit","page":"QPU","title":"Snowflurry.is_native_circuit","text":"is_native_circuit(\n    circuit::QuantumCircuit,\n    connectivity::GeometricConnectivity,\n    native_gates::Vector{DataType} = set_of_native_gates,\n)::Tuple{Bool,String}\n\nReturns (true, \"\") if the circuit only contains native instructions for the connectivity and the list of possible native_gates. It returns (false, \"error_message\") otherwise. The native gates for the Anyon QPUs are used by default.\n\nSee is_native_instruction for more details about the identification of native instructions.\n\nExample\n\njulia> connectivity = LineConnectivity(3)\nLineConnectivity{3}\n1──2──3\n\n\njulia> native_circuit = QuantumCircuit(\n           qubit_count = 3,\n           instructions = [sigma_x(1), control_z(2, 3)]\n       )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X───────\n               \nq[2]:───────*──\n            |  \nq[3]:───────Z──\n               \n\njulia> is_native_circuit(native_circuit, connectivity)\n(true, \"\")\n\njulia> foreign_circuit = QuantumCircuit(\n                  qubit_count = 3,\n                  instructions = [sigma_x(1), control_x(2, 3)]\n              )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X───────\n               \nq[2]:───────*──\n            |  \nq[3]:───────X──\n               \n\njulia> is_native_circuit(foreign_circuit, connectivity)\n(false, \"Instruction type Gate{Snowflurry.ControlX} with targets [2, 3] is not native on the connectivity\")\n\njulia> is_native_circuit(\n            foreign_circuit,\n            connectivity,\n            [Snowflurry.ControlX, Snowflurry.SigmaX]\n        )\n(true, \"\")\n\n\nThe folowing circuit is not native because the Toffoli gate is applied to more than two qubits:\n\njulia> foreign_circuit = QuantumCircuit(\n           qubit_count = 3,\n           instructions = [sigma_x(1), toffoli(1, 2, 3)]\n       )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────*──\n            |  \nq[2]:───────*──\n            |  \nq[3]:───────X──\n               \n\njulia> is_native_circuit(\n            foreign_circuit,\n            connectivity,\n            [Snowflurry.Toffoli, Snowflurry.SigmaX]\n        )\n(false, \"Instruction type Gate{Snowflurry.Toffoli} with targets [1, 2, 3] is not native on the connectivity\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.print_connectivity","page":"QPU","title":"Snowflurry.print_connectivity","text":"print_connectivity(\n    connectivity::LineConnectivity,\n    ::Vector{Int} = Int[],\n    io::IO = stdout\n)\n\nPrints the connectivity to io.\n\nQubits with their index in path are highlighted.\n\nExample\n\njulia> print_connectivity(LineConnectivity(3))\n1──2──3\n\n\n\n\n\n\nprint_connectivity(\n    connectivity::LatticeConnectivity,\n    path::Vector{Int} = Vector{Int}(),\n    io::IO = stdout,\n)\n\nPrints the connectivity to io.\n\nQubits with their index in path are highlighted.\n\nExample\n\njulia> connectivity=LatticeConnectivity(3,3);\n\njulia> path = path_search(1, 3, connectivity);\n\njulia> print_connectivity(connectivity, path)\n     (1)\n      | \n 7 ──(4)── 2 \n      |    | \n     (8)──(5)──(3)\n           |    | \n           9 ── 6 \n\n\n\n\n\n\nprint_connectivity(qpu::AbstractQPU, io::IO = stdout)\n\nPrints the qubit connectivity of the qpu to io.\n\nExample\n\njulia> qpu = AnyonYukonQPU(\n           host = \"http://example.anyonsys.com\",\n           user = \"test_user\",\n           access_token = \"not_a_real_access_token\",\n           project_id = \"test-project\",\n           realm = \"test-realm\"\n       )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6\n   connectivity_type:  linear\n   realm:         test-realm\n\n\njulia> print_connectivity(qpu)\n1──2──3──4──5──6\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_connectivity","page":"QPU","title":"Snowflurry.get_connectivity","text":"get_connectivity(qpu::AbstractQPU)\n\nReturns the qubit connectivity of a qpu.\n\nExample\n\njulia> qpu = AnyonYukonQPU(\n       host = \"http://example.anyonsys.com\",\n       user = \"test_user\",\n       access_token = \"not_a_real_access_token\",\n       project_id = \"test-project\",\n       realm = \"test-realm\"\n       )\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6\n   connectivity_type:  linear\n   realm:         test-realm\n\n\njulia> get_connectivity(qpu)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_connectivity_label","page":"QPU","title":"Snowflurry.get_connectivity_label","text":"get_connectivity_label(connectivity::AbstractConnectivity)\n\nReturns the label of the connectivity.\n\nExample\n\njulia> get_connectivity_label(LineConnectivity(6))\n\"linear\"\n\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basics.html#Basic-Concepts","page":"Basics","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorials/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Quantum computation involves the application of quantum operations to some qubits. A convenient way to represent this sequence of operations is to use a quantum circuit.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start with an example.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The first step is to import Snowflurry:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using Snowflurry","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can then create an empty QuantumCircuit by specifying the largest qubit index (qubit_count) and the number of classical bits (bit_count):","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c = QuantumCircuit(qubit_count = 2, bit_count = 2)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In most cases, it can be assumed that qubit_count is equal to the number of qubits in the circuit. See Circuit Transpilation for more details about the relationship between the largest qubit index and the number of qubits. The classical bits (or result bits) form a classical register, where each bit stores the output of a Readout operation on a particular qubit.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The bit_count parameter is optional. The bit_count is set to the same value as the qubit_count if the bit_count is not provided:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c = QuantumCircuit(qubit_count = 2)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can visualize a QuantumCircuit object at any point by printing it:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nIn Snowflurry, every qubit is initially in state left0rightrangle (ground state).","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Our circuit contains no quantum operations and it looks empty! Let's add some!","category":"page"},{"location":"tutorials/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Unitary quantum operations are commonly called quantum logic gates or simply gates. These gates can be categorized as single-qubit gates, two-qubit gates or multi-qubit gates.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by adding a single-qubit gate called a Hadamard gate to our circuit, c. The Hadamard gate, H, is one of the most common gates since it allows us to create the following state:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"H left 0 rightrangle = frac1sqrt2left(left0rightrangle + left1rightrangle right)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"This state is an equal superposition of the basis states 0rangle and 1rangle. It allows us to exploit quantum parallelism (i.e. perform operations on multiple basis states simultaneously)!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We construct a Hadamard gate that operates on qubit 1 by calling the hadamard() function with the parameter target set to 1. We add the gate to our circuit c by calling the push! function:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c, hadamard(1))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"warning: Indexing in Julia\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Note the exclamation mark at the end of push!. This indicates that we have called a mutating function that modifies at least the first argument. In this case, it updates our circuit c.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"If we now print circuit c, we will see the following output:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's now entangle our qubits. We can achieve this with a control_x gate. This is a two-qubit gate which is also known as a CNOT gate. We set the first argument of the control_x function to 1 and the second argument to 2. This indicates that qubit 1 is the control_qubit while qubit 2 is the target_qubit. This means that a bit flip, sigma_x, is applied to qubit 2 if qubit 1 is in state 1rangle. Qubit 2 remains unchanged if qubit 1 is in state 0rangle. ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's add our CNOT gate to our circuit c:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c, control_x(1, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Voilà! We just used Snowflurry to create a quantum circuit that exploits quantum parallelism and entanglement. The circuit places our two-qubit register in the maximally-entangled quantum state","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"psirangle = frac1sqrt2left(left00rightrangle+left11rightrangleright)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"This state is one of the four celebrated Bell states, which are also known as the EPR states. These states do not have classical counterparts. They form building blocks for many interesting concepts in quantum computing and quantum communication.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Qubit ordering convention\nIn Snowflurry, the leftmost qubit in a state is associated with the first qubit in a   circuit. For example, if a circuit is in state 01rangle, it means that qubit 1 is   in state 0rangle and qubit 2 is in state 1rangle.","category":"page"},{"location":"tutorials/basics.html#Circuit-Simulations","page":"Basics","title":"Circuit Simulations","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can verify that our circuit performs as expected by simulating it on our local machine:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"simulate(c)\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The output of the simulate() function is a Ket object. A Ket is a complex vector that represents the state of a quantum object such as our two-qubit system. This state is also known as a wave function.","category":"page"},{"location":"tutorials/basics.html#Histograms","page":"Basics","title":"Histograms","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the previous section, we used the simulate function to obtain the state of a two-qubit register after applying our circuit, c. However, in the real world, we cannot directly determine the state of a quantum register. Rather, we need to execute the quantum circuit several times on a quantum processor and measure the state of the qubits after every circuit execution. Each circuit execution is known as a shot. The result of each shot is a bit string that tells us the outcome of the measurements on every qubit. For instance, the bit string 01 indicates that qubit 1 was in state left0rightrangle after the measurement while qubit 2 was in state left1rightrangle. The probability of obtaining a particular bit string depends on the state of our quantum register.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can also mimic this behavior using a simulator. This can be achieved by calling the plot_histogram function from the SnowflurryPlots library. For example, we can generate a histogram that shows the measurement output distribution after running the circuit c for a given number of shots, let's say 100 times, on a quantum computer simulator.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nWe must add readout operations to specify which qubits we want to measure. We will   explore readouts in more details in the next tutorial.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's generate a histogram for our circuit:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using SnowflurryPlots\npush!(c, readout(1, 1), readout(2, 2))\nplot_histogram(c, 100)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"(Image: Measurement results histogram)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the next tutorial, we will discuss how to run our quantum circuit on a virtual quantum processor.","category":"page"},{"location":"tutorials/anyon_qpu.html#Running-a-Circuit-on-Real-Hardware","page":"Real Hardware","title":"Running a Circuit on Real Hardware","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"In the previous tutorial, we learned how to execute a quantum circuit on a virtual QPU. We also learned that every QPU object should adhere to the AbstractQPU interface.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"In this tutorial, we will learn how to submit a job to a real quantum processor. At the moment, we have only implemented QPU types for Anyon's quantum processors. However, we welcome contributions from other members of the community. We also invite other hardware vendors to use Snowflurry for their quantum processors.","category":"page"},{"location":"tutorials/anyon_qpu.html#Anyon-QPU","page":"Real Hardware","title":"Anyon QPU","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"note: Note\nThis tutorial is written for the selected partners and users who have been granted access   to Anyon's hardware.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"The current release of Snowflurry supports Anyon's Yukon quantum processor (see AnyonYukonQPU). The processor consists of an array of 6 tunable superconducting transmon qubits interleaved with 5 tunable couplers. The following generation of QPU, called Yamaska (see AnyonYamaskaQPU), is also supported in Snowflurry. This QPU contains 24 qubits and 35 couplers that are positioned in a two-dimensional lattice. ","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"We can start by defining a qpu variable that points to the host computer that will queue jobs and submit them to the quantum processor:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"using Snowflurry\n\nuser = ENV[\"THUNDERHEAD_USER\"]\ntoken = ENV[\"THUNDERHEAD_API_TOKEN\"]\nhost = ENV[\"THUNDERHEAD_HOST\"]\nproject = ENV[\"THUNDERHEAD_PROJECT_ID\"]\nrealm = ENV[\"THUNDERHEAD_REALM\"]\n\nqpu = AnyonYukonQPU(host = host, user = user, access_token = token, project_id = project, realm = realm)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"We should also provide user credentials and a project_id if needed. These are required in order to submit jobs through Thunderhead.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"danger: Keep your credentials safe!\nIf you plan to make your code public or work in a shared environment, it is best to use   environment variables to set the user credentials rather than hardcoding them!","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"We can now print the qpu object to obtain further information about the hardware:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"println(qpu)\n\n# output\n\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    test-project\n   qubit_count:   6\n   connectivity_type:  linear\n   realm:         test-realm","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"Alternatively, we can use the get_metadata function to obtain a Dict object that contains information about the qpu:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"get_metadata(qpu)\n\n# output\n\nDict{String, Union{Int64, Vector{Int64}, Vector{Tuple{Int64, Int64}}, String}} with 10 entries:\n  \"qubit_count\"          => 6\n  \"generation\"           => \"Yukon\"\n  \"status\"               => \"online\"\n  \"manufacturer\"         => \"Anyon Systems Inc.\"\n  \"realm\"                => \"test-realm\"\n  \"excluded_connections\" => Tuple{Int64, Int64}[]\n  \"serial_number\"        => \"ANYK202201\"\n  \"project_id\"           => \"test-project\"\n  \"connectivity_type\"    => \"linear\"\n  \"excluded_positions\"   => Int64[]","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"We now build a small circuit that creates a Bell state, as was presented in the previous tutorials:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"c = QuantumCircuit(qubit_count = 2)\npush!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──","category":"page"},{"location":"tutorials/anyon_qpu.html#Circuit-Transpilation","page":"Real Hardware","title":"Circuit Transpilation","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"The previous circuit cannot be directly executed on the quantum processor. This is because the quantum processor only implements a set of native gates. This means that any arbitrary gate should first be transpiled into a set of native gates that can run on the QPU.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"If we examine the src/anyon/anyon.jl file, we notice that the Anyon processors implement the following set of native gates:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"set_of_native_gates = [\n    Identity,\n    PhaseShift,\n    Pi8,\n    Pi8Dagger,\n    SigmaX,\n    SigmaY,\n    SigmaZ,\n    X90,\n    XM90,\n    Y90,\n    YM90,\n    Z90,\n    ZM90,\n    ControlZ,\n]","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"Snowflurry is designed to allow users to design and use their own transpilers for different  QPUs. Alternatively, a user may opt not to use the default transpilers that are implemented for each QPU type.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"Let's see how we can transpile the above circuit, c, to a circuit that can run on one of Anyon's QPUs. We first define a transpiler object that refers to the default transpiler for the AnyonYukonQPU:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"transpiler = get_transpiler(qpu)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"Next, let's transpile the original circuit:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"c_transpiled = transpile(transpiler, c)\n\n# output\n\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──Z_90────────────X_90────Z_90────────────────────*────────────────────────────✲───────\n                                                       |                                    \nq[2]:──────────Z_90────────────────────X_90────Z_90────Z────Z_90────X_90────Z_90─────────✲──","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"note: Note\nIt may be beneficial to select specific qubits on the QPU in order to reduce the impact   of noise on the results. For instance, one could select qubits 2 and 6 for the   execution of a two-qubit circuit. This requires setting qubit_count to 6 for the   construction of the QuantumCircuit since qubit_count represents the largest   qubit index. Setting qubit_count to 2 will not enable the application of a quantum   gate to qubit 6 even though gates are only applied to two qubits.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"The final circuit c_transpiled is now ready to be submitted to the QPU","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"shot_count = 200\nresult, qpu_time = run_job(qpu, c_transpiled, shot_count)\nprintln(result)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"where printing the results yields","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"Dict(\"11\" => 97, \"00\" => 83, \"01\" => 11, \"10\" => 9)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"The results show that states left00rightrangle and left11rightrangle were measured most often. States left01rightrangle and left10rightrangle were also measured a few times due to errors in the computation.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real Hardware","title":"Real Hardware","text":"note: Note\nThe user can skip the explicit transpilation step by using the transpile_and_run_job   function. This function uses the default transpiler of the QPU and submits the job to   the machine.","category":"page"},{"location":"library/pauli_sim.html#Pauli-Simulator","page":"Pauli Simulator","title":"Pauli Simulator","text":"","category":"section"},{"location":"library/pauli_sim.html","page":"Pauli Simulator","title":"Pauli Simulator","text":"Snowflurry provides tools for the efficient storage and manipulation of Pauli group elements.","category":"page"},{"location":"library/pauli_sim.html#Snowflurry.PauliGroupElement","page":"Pauli Simulator","title":"Snowflurry.PauliGroupElement","text":"PauliGroupElement\n\nA Pauli group element which is represented using the approach of Dehaene and De Moor (2003).\n\nThe get_pauli functions should be used to generate PauliGroupElement objects.\n\n\n\n\n\n","category":"type"},{"location":"library/pauli_sim.html#Snowflurry.get_pauli","page":"Pauli Simulator","title":"Snowflurry.get_pauli","text":"get_pauli(\n    circuit::QuantumCircuit;\n    imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0\n)::PauliGroupElement\n\nReturns a PauliGroupElement given a circuit containing Pauli gates.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. The Pauli operators are specified in the circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\n\nIf multiple Pauli gates are applied to the same qubit in the circuit, the gates are multiplied with the first gate in the circuit being the rightmost gate in the multiplication.\n\njulia> circuit = QuantumCircuit(qubit_count = 1);\n\njulia> push!(circuit, sigma_x(1), sigma_z(1))\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Z──\n               \n\n\n\njulia> get_pauli(circuit)\nPauli Group Element:\n1.0im*Y(1)\n\n\n\n\n\n\n\n\nget_pauli(\n    gate::AbstractGateSymbol,\n    num_qubits::Integer;\n    imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0\n)::PauliGroupElement\n\nReturns a PauliGroupElement given a gate and the number of qubits.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. In this variant of the get_pauli function, a single Pauli operator is set by providing a gate. The number of qubits is specified by num_qubits.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> get_pauli(gate, num_qubits)\nPauli Group Element:\n1.0*X(2)\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Base.:*-Tuple{Snowflurry.PauliGroupElement, Snowflurry.PauliGroupElement}","page":"Pauli Simulator","title":"Base.:*","text":"Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement\n\nReturns the product of two PauliGroupElement objects.\n\nThe PauliGroupElement objects must be associated with the same number of qubits.\n\nExamples\n\njulia> pauli_z = get_pauli(sigma_z(1), 1)\nPauli Group Element:\n1.0*Z(1)\n\n\n\njulia> pauli_y = get_pauli(sigma_y(1), 1)\nPauli Group Element:\n1.0*Y(1)\n\n\n\njulia> pauli_z*pauli_y\nPauli Group Element:\n-1.0im*X(1)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/pauli_sim.html#Snowflurry.get_quantum_circuit","page":"Pauli Simulator","title":"Snowflurry.get_quantum_circuit","text":"get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit\n\nReturns the Pauli gates of a PauliGroupElement as a QuantumCircuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> pauli = get_pauli(circuit, imaginary_exponent = 1, negative_exponent = 1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\njulia> get_quantum_circuit(pauli)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Snowflurry.get_negative_exponent","page":"Pauli Simulator","title":"Snowflurry.get_negative_exponent","text":"get_negative_exponent(pauli::PauliGroupElement)::Int\n\nReturns the negative exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, negative_exponent = 1)\nPauli Group Element:\n-1.0*X(2)\n\n\n\njulia> get_negative_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Snowflurry.get_imaginary_exponent","page":"Pauli Simulator","title":"Snowflurry.get_imaginary_exponent","text":"get_imaginary_exponent(pauli::PauliGroupElement)::Int\n\nReturns the imaginary exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, imaginary_exponent = 1)\nPauli Group Element:\n1.0im*X(2)\n\n\n\njulia> get_imaginary_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Quantum-Gates","page":"Quantum Gates","title":"Quantum Gates","text":"","category":"section"},{"location":"library/quantum_gates.html#Snowflurry.AbstractGateSymbol","page":"Quantum Gates","title":"Snowflurry.AbstractGateSymbol","text":"AbstractGateSymbol\n\nA GateSymbol is an instantiation of an AbstractGateSymbol. It can be passed as an argument to a Gate constuctor, where a Gate is also associated with target qubits. A Gate will be placed on those target_qubits if it is added to a QuantumCircuit. AbstractGateSymbol is useful for dispatching all the GateSymbols to default implementations of functions such as get_connected_qubits(). Those functions can be specialized for GateSymbols requiring a different implementation. \n\nAbstractGateSymbol is an abstract type, which means that it cannot be instantiated.  Each concrete type of GateSymbols is a struct which is a subtype of AbstractGateSymbol. Each descendant of AbstractGateSymbol must implement at least the following methods:\n\nget_operator(gate::AbstractGateSymbol, T::Type{<:Complex}=ComplexF64})::AbstractOperator\nget_num_connected_qubits(gate::AbstractGateSymbol)::Integer\n\nExamples\n\nA struct must be defined for each new GateSymbol type. The following X_45 GateSymbol applies a 45 rotation about the X axis:\n\njulia> struct X45 <: AbstractGateSymbol\n       end;\n\nWe need to define how many connected qubits are needed for our new GateSymbol:\n\njulia> Snowflurry.get_num_connected_qubits(::X45) = 1\n\n\nA Gate constructor must be defined as\n\njulia> x_45(target::Integer) = Gate(X45(), [target]);\n\nalong with an Operator constructor, with default precision ComplexF64, which is defined as\n\njulia> x_45(T::Type{<:Complex} = ComplexF64) = rotation_x(π/4, T);\n\n\nTo simulate the effects of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended:\n\njulia> function Snowflurry.get_operator(gate::X45, T::Type{<:Complex} = ComplexF64)\n          return rotation_x(π/4, T)\n       end\n\n\nThe gate inverse can also be specified by extending the inv function:\n\njulia> Base.inv(::X45) = Snowflurry.RotationX(-π/4);\n\n\nAn instance of the X_45 Gate can now be created, along with its inverse:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Snowflurry.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\nTo enable the printing of a QuantumCircuit containing our new GateSymbol type, a display symbol must be defined as follows:\n\njulia> Snowflurry.gates_display_symbols[X45] = [\"X45\"];\n\n\nIf this Gate will be sent as an instruction to a hardware QPU,  an instruction String must be defined:\n\njulia> Snowflurry.instruction_symbols[X45] = \"x45\";\n\n\nA circuit containing this Gate can now be constructed:\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [x_45_gate])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──X45──\n\nq[2]:───────\n\n\nIn addition, a Controlled{X45} gate can be constructed using:\n\njulia> control = 1; target = 2;\n\njulia> controlled(x_45(target), [control])\nGate Object: Controlled{X45}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 + 0.0im    0.0 + 0.0im    0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.Controlled","page":"Quantum Gates","title":"Snowflurry.Controlled","text":"Controlled{G<:AbstractGateSymbol}<:AbstractGateSymbol\n\nThe Controlled object allows the construction of a controlled AbstractGateSymbol using an Operator  (the kernel) and the corresponding number of control qubits. A helper function, controlled can be used to easily create both controlled AbstractGateSymbols and controlled Gates. A call to apply_gate will be dispatched to the optimized routine if it exists. Otherwise, it will fall back to casting the operator into the equivalent DenseOperator and applying the created operator.\n\nExamples\n\nWe can use the controlled function to create a controlled-Hadamard gate:\n\njulia> controlled_hadamard = controlled(hadamard(2), [1])\nGate Object: Controlled{Snowflurry.Hadamard}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    0.7071067811865475 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    -0.7071067811865475 + 0.0im\n\n\nIt can then be used in a QuantumCircuit as any other Gate, and its display symbol is  inherited from the display symbol of the single-target Hadamard Gate:\n\njulia> circuit=QuantumCircuit(qubit_count=2,instructions = [controlled_hadamard])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──H──\n          \n\nIn general, a Controlled struct with an arbitraty number of targets and controls can be  constructed. For instance, the following example constructs the equivalent of a Toffoli Gate,  but as a ConnectedGate{SigmaX} with control_qubits=[1,2] and target_qubit=[3]:\n\njulia> toffoli_as_controlled_gate = controlled(sigma_x(3), [1, 2])\nGate Object: Controlled{Snowflurry.SigmaX}\nConnected_qubits\t: [1, 2, 3]\nOperator:\n(8, 8)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.Gate","page":"Quantum Gates","title":"Snowflurry.Gate","text":"Gate <: AbstractInstruction\n\nGate is an implementation of an AbstractInstruction that specifies an AbstractGateSymbol and its placement inside a QuantumCircuit.  The placement corresponds to the target qubit (or qubits) on which the Gate operates.\n\nExamples\n\njulia> gate = iswap(1, 2)\nGate Object: Snowflurry.ISwap\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.SwapLikeOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\njulia> gate = universal(3, pi/2, -pi/2, pi/2)\nGate Object: Snowflurry.Universal\nParameters:\ntheta\t: 1.5707963267948966\nphi\t: -1.5707963267948966\nlambda\t: 1.5707963267948966\n\nConnected_qubits\t: [3]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -4.329780281177466e-17 - 0.7071067811865475im\n4.329780281177466e-17 - 0.7071067811865475im    0.7071067811865476 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.eye","page":"Quantum Gates","title":"Snowflurry.eye","text":"eye(),\neye(size::Integer)\n\nReturn the identity matrix as a DenseOperator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\nCalling eye(size) will produce an identity matrix DenseOperator  with dimensions (size,size).\n\nExamples\n\njulia> eye()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\njulia> eye(4)\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.identity_gate","page":"Quantum Gates","title":"Snowflurry.identity_gate","text":"identity_gate(target)\n\nReturn the Identity Gate, which applies the identity_gate() IdentityOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_p","page":"Quantum Gates","title":"Snowflurry.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_m","page":"Quantum Gates","title":"Snowflurry.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_x","page":"Quantum Gates","title":"Snowflurry.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_y","page":"Quantum Gates","title":"Snowflurry.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_z","page":"Quantum Gates","title":"Snowflurry.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.hadamard","page":"Quantum Gates","title":"Snowflurry.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.pi_8","page":"Quantum Gates","title":"Snowflurry.pi_8","text":"pi_8()\n\nReturn the Operator for the π8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.pi_8_dagger","page":"Quantum Gates","title":"Snowflurry.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.x_90","page":"Quantum Gates","title":"Snowflurry.x_90","text":"x_90()\n\nReturn the Operator which applies a π2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90 rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.x_minus_90","page":"Quantum Gates","title":"Snowflurry.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.y_90","page":"Quantum Gates","title":"Snowflurry.y_90","text":"y_90()\n\nReturn the Operator which applies a π2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90 rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.y_minus_90","page":"Quantum Gates","title":"Snowflurry.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.z_90","page":"Quantum Gates","title":"Snowflurry.z_90","text":"z_90()\n\nReturn the Operator which applies a π2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(fracpi2right) = beginbmatrix\n    e^-ipi4  0 05em\n    0  e^ipi4\nendbmatrix\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90 rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.z_minus_90","page":"Quantum Gates","title":"Snowflurry.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the Z axis. The Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    e^ipi4  0 05em\n    0  e^-ipi4\nendbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation","page":"Quantum Gates","title":"Snowflurry.rotation","text":"rotation(theta, phi)\n\nReturn the Operator that applies a rotation theta about the axis vecn=cos(phi)X+sin(phi)Y.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em\n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the axis vecn=cos(phi)X+sin(phi)Y.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_x","page":"Quantum Gates","title":"Snowflurry.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em\n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_y","page":"Quantum Gates","title":"Snowflurry.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em\nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_z","page":"Quantum Gates","title":"Snowflurry.rotation_z","text":"rotation_z(lambda)\n\nReturn the DiagonalOperator that applies a rotation about the Z axis.\n\nThe DiagonalOperator is defined as:\n\nR_z(lambda) = beginbmatrix\n    e^-ilambda2  0 05em\n    0  e^ilambda2\nendbmatrix\n\n\n\n\n\nrotation_z(target, lambda)\n\nReturn a Gate that applies a rotation lambda about the Z axis of the target qubit.\n\nThe corresponding Operator is rotation_z(lambda).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.root_zz","page":"Quantum Gates","title":"Snowflurry.root_zz","text":"root_zz()\n\nReturn the DiagonalOperator that, when applied twice in sequence, applies rotations about the Z axes of -fracpi2 to the first qubit and fracpi2 to the second one.\n\nThe DiagonalOperator is defined as:\n\nR_ZZ = beginbmatrix\n    1-i  0  0  0 \n    0  1+i  0  0 \n    0  0  1+i  0 \n    0  0  0  1-i \nendbmatrix\n\n\n\n\n\nroot_zz(qubit_1, qubit_2)\n\nReturn the root of a ZZ Gate. The application of two ZZ gates in sequence is equivalent to  the application of one rotation_z(-π/2) Operator to qubit_1 and one rotation_z(π/2) Operator to qubit_2.\n\nThe corresponding Operator is root_zz().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.root_zz_dagger","page":"Quantum Gates","title":"Snowflurry.root_zz_dagger","text":"root_zz_dagger()\n\nReturn the DiagonalOperator which is the complex conjugate of root_zz().\n\nThe DiagonalOperator is defined as:\n\nR_ZZ^dagger = beginbmatrix\n    1+i  0  0  0 \n    0  1-i  0  0 \n    0  0  1-i  0 \n    0  0  0  1+i \nendbmatrix\n\n\n\n\n\nroot_zz_dagger(qubit_1, qubit_2)\n\nReturn the complex conjugate of a root of ZZ Gate.\n\nThe corresponding Operator is root_zz_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.phase_shift","page":"Quantum Gates","title":"Snowflurry.phase_shift","text":"phase_shift(phi)\n\nReturn the DiagonalOperator that applies a phase shift phi.\n\nThe DiagonalOperator is defined as:\n\nP(phi) = beginbmatrix\n    1  0 05em\n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.universal","page":"Quantum Gates","title":"Snowflurry.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See Theorem 4.1 in Quantum Computation and Quantum Information by Nielsen and Chuang.\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em\n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See Theorem 4.1 in Quantum Computation and Quantum Information by Nielsen and Chuang.\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.control_z","page":"Quantum Gates","title":"Snowflurry.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.control_x","page":"Quantum Gates","title":"Snowflurry.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled-NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled-NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.iswap","page":"Quantum Gates","title":"Snowflurry.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.swap","page":"Quantum Gates","title":"Snowflurry.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.toffoli","page":"Quantum Gates","title":"Snowflurry.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.iswap_dagger","page":"Quantum Gates","title":"Snowflurry.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Base.:*-Tuple{Gate, Ket}","page":"Quantum Gates","title":"Base.:*","text":"Base.:*(M::Gate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1) * ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_gates.html#Snowflurry.apply_instruction!","page":"Quantum Gates","title":"Snowflurry.apply_instruction!","text":"apply_instruction!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_instruction!(ψ_0, sigma_x(1))\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_operator","page":"Quantum Gates","title":"Snowflurry.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated with a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(get_gate_symbol(x))\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Base.inv-Tuple{AbstractGateSymbol}","page":"Quantum Gates","title":"Base.inv","text":"inv(gate::AbstractGateSymbol)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Snowflurry.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Snowflurry.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_gates.html#Snowflurry.move_instruction","page":"Quantum Gates","title":"Snowflurry.move_instruction","text":"move_instruction(gate::Gate,\n    qubit_mapping::AbstractDict{<:Integer,<:Integer})::AbstractGateSymbol\n\nReturns a copy of gate where the qubits on which the gate acts have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflurry.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> move_instruction(gate, Dict(1=>2))\nGate Object: Snowflurry.SigmaX\nConnected_qubits\t: [2]\nOperator:\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\nmove_instruction(\n    original_readout::Readout,\n    qubit_mapping::AbstractDict{T,T},\n)::AbstractInstruction where {T<:Integer}\n\nReturns a copy of original_readout where the qubits which the original_readout measures have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> r = readout(1, 1)\nExplicit Readout object:\n   connected_qubit: 1 \n   destination_bit: 1 \n\njulia> move_instruction(r, Dict(1 => 2))\nExplicit Readout object:\n   connected_qubit: 2 \n   destination_bit: 1 \n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_gate_symbol","page":"Quantum Gates","title":"Snowflurry.get_gate_symbol","text":"get_gate_symbol(gate::Gate)::AbstractGateSymbol\n\nReturns the symbol that is associated with a gate.\n\nExamples\n\njulia> gate = sigma_x(1);\n\njulia> get_gate_symbol(gate)\nSnowflurry.SigmaX()\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_connected_qubits","page":"Quantum Gates","title":"Snowflurry.get_connected_qubits","text":"get_connected_qubits(instruction::AbstractInstruction)::AbstractVector{Int}\n\nReturns the indices of the qubits on which the instruction is applied.\n\nExamples\n\njulia> get_connected_qubits(control_z(1, 3))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_num_connected_qubits","page":"Quantum Gates","title":"Snowflurry.get_num_connected_qubits","text":"get_num_connected_qubits(gate::AbstractGateSymbol)::Int\n\nReturns the number of qubits to which the gate is applied.\n\nExamples\n\njulia> get_num_connected_qubits(get_gate_symbol(control_z(1, 3)))\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_control_qubits","page":"Quantum Gates","title":"Snowflurry.get_control_qubits","text":"get_control_qubits(gate::Gate{<:AbstractControlledGateSymbol})\n\nReturns a list of the control qubits for a gate.\n\nExamples\n\njulia> get_control_qubits(toffoli(1, 4, 6))\n2-element Vector{Int64}:\n 1\n 4\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_target_qubits","page":"Quantum Gates","title":"Snowflurry.get_target_qubits","text":"get_target_qubits(gate::Gate{<:AbstractControlledGateSymbol})\n\nReturns a list of the target qubits for a gate.\n\nExamples\n\njulia> get_target_qubits(toffoli(1, 4, 6))\n1-element Vector{Int64}:\n 6\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_destination_bit","page":"Quantum Gates","title":"Snowflurry.get_destination_bit","text":"get_destination_bit(readout::Readout)::Int\n\nReturns the index of the classical bit to which the outcome of the readout is sent.\n\nExamples\n\njulia> get_destination_bit(readout(2, 3))\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_gate_parameters","page":"Quantum Gates","title":"Snowflurry.get_gate_parameters","text":"get_gate_parameters(gate::AbstractGateSymbol)::Dict{String,Real}\n\nReturns a Dict containing the name and the value of each parameter in a gate.\n\nExamples\n\njulia> get_gate_parameters(get_gate_symbol(universal(1, π/2, π/4, -π/3)))\nDict{String, Float64} with 3 entries:\n  \"theta\"  => 1.5708\n  \"phi\"    => 0.785398\n  \"lambda\" => -1.0472\n\n\n\n\n\n\n","category":"function"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The following installation steps are for people interested in using Snowflurry in their own applications. If you are interested in helping to develop Snowflurry, head right over to our Developing Snowflurry page.","category":"page"},{"location":"getting_started.html#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Make sure your system has Julia installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We officially support the latest stable release and the latest Long-Term Support (LTS) release. Any release in between should work (please submit a Github issue if they don't), but we only actively test against the LTS and the latest stable version.","category":"page"},{"location":"getting_started.html#Installing-the-Snowflurry-package","page":"Getting Started","title":"Installing the Snowflurry package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The latest release of Snowflurry can be pulled from JuliaHub and installed with the following command:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"Snowflurry\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"This adds the Snowflurry package to the current Julia Environment.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Snowflurry is under active development. To use the development version, the main branch from Github can be installed instead using the following commands in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/SnowflurrySDK/Snowflurry.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nThe main branch of Snowflurry targets new internal infrastructure. Existing users should use the latest stable release instead.","category":"page"},{"location":"getting_started.html#Installing-the-SnowflurryPlots-package","page":"Getting Started","title":"Installing the SnowflurryPlots package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Multiple visualization tools are available in the SnowflurryPlots package. After installing Snowflurry, the SnowflurryPlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/SnowflurrySDK/SnowflurryPlots.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html#Typical-workflow","page":"Getting Started","title":"Typical workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"A typical workflow to execute a quantum circuit on a quantum service consists of these three steps:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Create: Build the circuit using quantum gates.\nTranspile: Transform the circuit into an equivalent one, but with improved performance and   guaranteed compatibility with the chosen quantum service.\nExecute: Run the compiled circuits on the specified quantum service. The quantum service   could be a remote quantum hardware or a local simulator.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Now is the time to start with Snowflurry and go over the tutorials.","category":"page"},{"location":"library/quantum_toolkit.html#Quantum-Toolkit","page":"Quantum Toolkit","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library/quantum_toolkit.html#Basic-Quantum-Objects","page":"Quantum Toolkit","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library/quantum_toolkit.html","page":"Quantum Toolkit","title":"Quantum Toolkit","text":"There are three basic quantum objects in Snowflurry to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library/quantum_toolkit.html#Snowflurry.Ket","page":"Quantum Toolkit","title":"Snowflurry.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.   A Ket representing a system with a qubit count of n=2 has 2^n states.  By convention, qubit 1 is the leftmost bit, followed by every subsequent qubit.  Hence, a 2-qubit Ket has 4 complex-valued coefficients a_ij, each corresponding to state leftijrightrangle, in the following order:\n\npsi = beginbmatrix\n    a_00  \n    a_10  \n    a_01  \n    a_11  \n    endbmatrix\n\nExamples\n\nA Ket can be initialized by using a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 4)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\nAlthough NOT the preferred way, one can also directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflurry\n\njulia> ψ = Ket([1.0; 0.0; 0.0; 0.0])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.Bra","page":"Quantum Toolkit","title":"Snowflurry.Bra","text":"A structure representing a Bra (i.e., a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.DiagonalOperator","page":"Quantum Toolkit","title":"Snowflurry.DiagonalOperator","text":"DiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a diagonal quantum Operator (i.e., a complex matrix of element type T, with non-zero elements all lying on the diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.AntiDiagonalOperator","page":"Quantum Toolkit","title":"Snowflurry.AntiDiagonalOperator","text":"AntiDiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing an anti-diagonal quantum Operator (i.e., a complex matrix of element type T, with non-zero elements all lying on the cross-diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> AntiDiagonalOperator([1, 2])\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.DenseOperator","page":"Quantum Toolkit","title":"Snowflurry.DenseOperator","text":"DenseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a full (dense) matrix representation of size NxN and containing elements of type T.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2, -π/4)  \n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.SwapLikeOperator","page":"Quantum Toolkit","title":"Snowflurry.SwapLikeOperator","text":"SwapLikeOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator performing a \"swap\" operation, with element type T. A phase value is applied to the swapped qubit coefficients. This operator is always of size 4x4.\n\nFor example, the iswap Operator can be built using a phase=0.0 + 1.0im by calling:\n\njulia> SwapLikeOperator(0.0 + 1.0im)\n(4, 4)-element Snowflurry.SwapLikeOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.IdentityOperator","page":"Quantum Toolkit","title":"Snowflurry.IdentityOperator","text":"IdentityOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing the identity quantum operator, with element type T. This operator is always of size 2x2.\n\nExample\n\njulia> IdentityOperator()\n(2, 2)-element Snowflurry.IdentityOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.SparseOperator","page":"Quantum Toolkit","title":"Snowflurry.SparseOperator","text":"SparseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a sparse (CSR) matrix representation, with element type T. The equivalent dense matrix would have size NxN.\n\nwarning: Warning\nThe apply_operator() method is not implemented for this operator type. Try using DenseOperator instead.\n\nExamples\n\njulia> z = SparseOperator([-1.0 1.0;0.0 -1.0])\n(2, 2)-element Snowflurry.SparseOperator:\nUnderlying data ComplexF64:\n -1.0 + 0.0im   1.0 + 0.0im\n       ⋅       -1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.Readout","page":"Quantum Toolkit","title":"Snowflurry.Readout","text":"Readout <: AbstractInstruction\n\nReadout is an implementation of an AbstractInstruction that specifies  an explicit measurement on a particular qubit, and the destination bit in  the classical result registry (classical bit). It is built using the readout(qubit::Int, bit::Int) helper function, where  the first argument is the target qubit, and the second is the destination classical bit. Measurements are always performed in the Z basis (also known as the computational basis).\n\nExamples\n\njulia> r = readout(1, 2)\nExplicit Readout object:\n   connected_qubit: 1 \n   destination_bit: 2 \n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.readout","page":"Quantum Toolkit","title":"Snowflurry.readout","text":"readout(qubit::Int, bit::Int)\n\nReturn a Readout AbstractInstruction, which performs a  readout on the target qubit, and places the result in the destination bit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.adjoint","page":"Quantum Toolkit","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.is_hermitian","page":"Quantum Toolkit","title":"Snowflurry.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e., self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.exp-Tuple{AbstractOperator}","page":"Quantum Toolkit","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Quantum Toolkit","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.expected_value-Tuple{AbstractOperator, Ket}","page":"Quantum Toolkit","title":"Snowflurry.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#SparseArrays.sparse","page":"Quantum Toolkit","title":"SparseArrays.sparse","text":"sparse(x::AbstractOperator)\n\nReturns a SparseOperator representation of x.\n\nExamples\n\njulia> z = sparse(sigma_z())\n(2, 2)-element Snowflurry.SparseOperator:\nUnderlying data ComplexF64:\n 1.0 + 0.0im        ⋅     \n      ⋅       -1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.eigen","page":"Quantum Toolkit","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.tr","page":"Quantum Toolkit","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.kron","page":"Quantum Toolkit","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.MultiBodySystem","page":"Quantum Toolkit","title":"Snowflurry.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.commute","page":"Quantum Toolkit","title":"Snowflurry.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x, σ_y)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.anticommute","page":"Quantum Toolkit","title":"Snowflurry.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x, σ_x)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.normalize!","page":"Quantum Toolkit","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ = Ket([1., 2., 4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Quantum Toolkit","title":"Snowflurry.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for left00rightrangle,  left10rightrangle, left01rightrangle, and left11rightrangle. \n\nnote: Note\nBy convention, qubit 1 is the leftmost bit, followed by every subsequent qubit.  left10rightrangle has qubit 1 in state left1rightrangle and qubit 2 in state left0rightrangle\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring  left00rightrangle is 50% and the probability of measuring left01rightrangle is also 50%.\n\njulia> ψ = 1/sqrt(2) * Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.ket2dm","page":"Quantum Toolkit","title":"Snowflurry.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.fock_dm","page":"Quantum Toolkit","title":"Snowflurry.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm = fock_dm(0, 2)\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.wigner","page":"Quantum Toolkit","title":"Snowflurry.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: 0.561815\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.moyal","page":"Quantum Toolkit","title":"Snowflurry.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\nnote: Note\nFock basis states numbering starts at 0.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.genlaguerre","page":"Quantum Toolkit","title":"Snowflurry.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_embed_operator","page":"Quantum Toolkit","title":"Snowflurry.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3, 2)\nSnowflurry.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1 = get_embed_operator(x, 1, system)\n(8, 8)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_qubits-Tuple{AbstractOperator}","page":"Quantum Toolkit","title":"Snowflurry.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. \n                          0. 0.])\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Quantum Toolkit","title":"Snowflurry.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_bodies","page":"Quantum Toolkit","title":"Snowflurry.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                          0. 0. 0.\n                          0. 0. 0.])\n(3, 3)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_bodies-2","page":"Quantum Toolkit","title":"Snowflurry.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.fock","page":"Quantum Toolkit","title":"Snowflurry.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith Fock basis of a Hilbert space with size hspace_size as a Ket.\n\nnote: Note\nFock basis states numbering starts at 0.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3, ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.spin_up","page":"Quantum Toolkit","title":"Snowflurry.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.spin_down","page":"Quantum Toolkit","title":"Snowflurry.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.create","page":"Quantum Toolkit","title":"Snowflurry.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.destroy","page":"Quantum Toolkit","title":"Snowflurry.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.number_op","page":"Quantum Toolkit","title":"Snowflurry.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.coherent","page":"Quantum Toolkit","title":"Snowflurry.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha (alpha) in a Fock space of size hspace_size. Note that alpha^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0, 20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20), ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.compare_kets","page":"Quantum Toolkit","title":"Snowflurry.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1., 2., 3., 4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ = π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im * δ) * ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0, ψ_1)\ntrue\n\njulia> apply_instruction!(ψ_1, sigma_x(1))\n4-element Ket{ComplexF64}:\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n\n\njulia> compare_kets(ψ_0, ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.compare_operators","page":"Quantum Toolkit","title":"Snowflurry.compare_operators","text":"compare_operators(H_0::AbstractOperator, H_1::AbstractOperator)::Bool\n\nChecks for equivalence allowing for a global phase difference between two input operators.\n\nExamples\n\njulia> H_0 = z_90()\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.7071067811865476 - 0.7071067811865475im    .\n.    0.7071067811865476 + 0.7071067811865475im\n\n\njulia> H_1 = phase_shift(pi / 2)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    6.123233995736766e-17 + 1.0im\n\n\njulia> compare_operators(H_0, H_1)\ntrue\n\njulia> H_1 *= sigma_x()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    1.0 + 0.0im\n6.123233995736766e-17 + 1.0im    0.0 + 0.0im\n\n\njulia> compare_operators(H_0, H_1) # no longer equivalent after applying sigma x\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_matrix","page":"Quantum Toolkit","title":"Snowflurry.get_matrix","text":"get_matrix(op::AbstractOperator)\n\nReturns the Matrix associated with operator op.\n\nExamples\n\njulia> z = sparse(sigma_z())\n(2, 2)-element Snowflurry.SparseOperator:\nUnderlying data ComplexF64:\n 1.0 + 0.0im        ⋅     \n      ⋅       -1.0 + 0.0im\n\njulia> z_matrix = get_matrix(z)\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"index.html#Snowflurry.jl","page":"Home","title":"Snowflurry.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflurry is a software package for quantum computing that is written entirely in Julia. It allows you to easily design quantum circuits, experiments, and algorithms. These can then be executed on real quantum hardware or quantum computer simulators using Snowflurry.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nSnowflurry has yet to reach version 1.0, but we intend to keep compatibility with what is documented here. We will only make a breaking change if something is broken. After version 1.0, the public API will be stable and only change with major releases.","category":"page"},{"location":"library/quantum_circuit.html#Quantum-Circuit","page":"Quantum Circuits","title":"Quantum Circuit","text":"","category":"section"},{"location":"library/quantum_circuit.html#Snowflurry.QuantumCircuit","page":"Quantum Circuits","title":"Snowflurry.QuantumCircuit","text":"QuantumCircuit(\n    qubit_count::Int,\n    bit_count::Int,\n    instructions::Vector{AbstractInstruction},\n    name::String = \"default\"\n)\nQuantumCircuit(circuit::QuantumCircuit)\n\nA data structure which describes a quantum circuit.\n\nFields\n\nqubit_count::Int – Largest qubit index (e.g., specifying qubit_count=n enables the                       use of qubits 1 to n).\nbit_count::Int – Optional: Number of classical bits (i.e., result register size).                     Defaults to qubit_count if unspecified.\ninstructions::Vector{AbstractInstruction} – Optional: Sequence of                                                AbstractInstructions (Gates and                                                Readouts) that operate on the qubits.                                                Defaults to an empty Vector.\nname::String – Optional: Name of the circuit and the corresponding job. It is used to                   identify the job when it is sent to a hardware or virtual QPU. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n\nA QuantumCircuit can be initialized with Gate and Readout structs:\n\njulia> c = QuantumCircuit(\n            qubit_count = 2,\n            instructions = [\n                hadamard(1),\n                sigma_x(2),\n                control_x(1, 2),\n                readout(1, 1),\n                readout(2, 2)\n            ])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────✲───────\n                 |            \nq[2]:───────X────X─────────✲──\n                              \n\nA deep copy of a QuantumCircuit can be obtained with the following function:\n\njulia> c_copy = QuantumCircuit(c)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────✲───────\n                 |            \nq[2]:───────X────X─────────✲──\n                              \n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_qubits","page":"Quantum Circuits","title":"Snowflurry.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. \n                          0. 0.])\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\nget_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\nget_num_qubits(circuit::QuantumCircuit)::Int\n\nReturns the number of qubits in a circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> get_num_qubits(c)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_bits","page":"Quantum Circuits","title":"Snowflurry.get_num_bits","text":"get_num_bits(circuit::QuantumCircuit)::Int\n\nReturns the number of classical bits in a circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2, bit_count=3);\n\njulia> get_num_bits(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_name","page":"Quantum Circuits","title":"Snowflurry.get_name","text":"get_name(circuit::QuantumCircuit)::String\n\nReturns the name of the circuit and the corresponding job.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2, name = \"my_circuit\");\n\njulia> get_name(c)\n\"my_circuit\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_circuit_instructions","page":"Quantum Circuits","title":"Snowflurry.get_circuit_instructions","text":"get_circuit_instructions(circuit::QuantumCircuit)::Vector{AbstractInstruction}\n\nReturns the list of instructions in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), control_z(1, 2)]);\n\njulia> get_circuit_instructions(c)\n2-element Vector{AbstractInstruction}:\n Gate Object: Snowflurry.Hadamard\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.7071067811865475 + 0.0im\n0.7071067811865475 + 0.0im    -0.7071067811865475 + 0.0im\n\n Gate Object: Snowflurry.ControlZ\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    -1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.push!","page":"Quantum Circuits","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gates::AbstractGateSymbol...)\n\nInserts one or more gates at the end of a circuit.\n\nA Vector of AbstractGateSymbol objects can be passed to this function by using splatting. More details about splatting are provided here.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> gate_list = [sigma_x(1), hadamard(2)];\n\njulia> push!(c, gate_list...)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────X───────\n                 |            \nq[2]:───────X────X─────────H──\n                              \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.pop!","page":"Quantum Circuits","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last instruction from circuit.instructions, and returns it.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nGate Object: Snowflurry.ControlX\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n\njulia> c\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.append!","page":"Quantum Circuits","title":"Base.append!","text":"append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)\n\nAppends one or more circuits_to_append to the base_circuit.\n\nThe circuits_to_append cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> append_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> append_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> append!(base, append_1, append_2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────Z────*──\n                 |  \nq[2]:────────────X──\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.prepend!","page":"Quantum Circuits","title":"Base.prepend!","text":"prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)\n\nPrepends one or more circuits_to_prepend to the base_circuit.\n\nThe order of the circuits_to_prepend is maintained (i.e., circuits_to_prepend[1] will appear leftmost in base_circuit). The circuits_to_prepend cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> prepend_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> prepend_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> prepend!(base, prepend_1, prepend_2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────*────X──\n            |       \nq[2]:───────X───────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.update_circuit_qubit_count","page":"Quantum Circuits","title":"Snowflurry.update_circuit_qubit_count","text":"update_circuit_qubit_count(\n    quantum_cicuit::QuantumCircuit,\n    qubit_count::Int,\n)::QuantumCircuit\n\nUpdates the qubit_count of the quantum_circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X──\n          \n\n\n\njulia> larger_circuit = update_circuit_qubit_count(circuit, 2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 1 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.simulate","page":"Quantum Circuits","title":"Snowflurry.simulate","text":"simulate(circuit::QuantumCircuit)::Ket\n\nPerforms an ideal simulation of the circuit and returns the final quantum state (i.e. the wave function). The simulator assumes that the initial state Psi corresponds to the zeroth Fock basis, i.e.: ψ = fock(0, 2^get_num_qubits(circuit)). The zeroth Fock basis corresponds to the initial state of most superconducting quantum processors, i.e.:\n\nPsirangle = 0rangle^otimes n\n\nwhere n is the number of qubits.\n\nnote: Note\nThe input circuit must not include Readout instructions. Use     simulate_shots for the simulation of circuits with Readout     instructions.\n\nThe simulation utilizes the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.simulate_shots","page":"Quantum Circuits","title":"Snowflurry.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results, as prescribed by the Readout instructions present in the circuit.  The distribution of measured states depends on the coefficients of the resulting state Ket.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──\n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Quantum Circuits","title":"Snowflurry.get_measurement_probabilities","text":"get_measurement_probabilities(\n    circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}]\n)::AbstractVector{<:Real}\n\nReturns a list of the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for left00rightrangle, left01rightrangle, left10rightrangle, and left11rightrangle.\n\nnote: Note\nBy convention, qubit 1 is the leftmost bit, followed by every subsequent qubit.  The notation left10rightrangle indicates that qubit 1 is in state left1rightrangle and qubit 2 in state left0rightrangle.\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring left10rightrangle is 50% and the probability of measuring left11rightrangle is also 50%:\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%:\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_circuit.html#Base.inv-Tuple{QuantumCircuit}","page":"Quantum Circuits","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.  Each gate is replaced by its corresponding inverse, and the order of gates is reversed.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_gates_per_type","page":"Quantum Circuits","title":"Snowflurry.get_num_gates_per_type","text":"get_num_gates_per_type(\n    circuit::QuantumCircuit\n)::AbstractDict{<: AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction symbols of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_gates","page":"Quantum Circuits","title":"Snowflurry.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.serialize_job","page":"Quantum Circuits","title":"Snowflurry.serialize_job","text":"serialize_job(circuit::QuantumCircuit,shot_count::Integer,host::String)\n\nCreates a JSON-formatted string that contains the circuit configuration that will be sent  to a QPU service. The URL for the QPU service corresponds to host while the number of circuit executions is equal to shot_count.\n\nnote: Note\nQubit and bit indices use zero-based indexing in the JSON encoding.\n\nExamples\n\njulia> c = QuantumCircuit(\n            qubit_count = 2,\n            instructions = [sigma_x(1)],\n            name = \"sigma_x job\"\n        )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \njulia> serialize_job(c, 10, \"machine\", \"project_id\")\n\"{\\\"shotCount\\\":10,\\\"name\\\":\\\"sigma_x job\\\",\\\"machineName\\\":\\\"machine\\\",\\\"projectID\\\":\\\"project_id\\\",\\\"type\\\":\\\"circuit\\\",\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}],\\\"bitCount\\\":2,\\\"qubitCount\\\":2}}\"\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.transpile","page":"Quantum Circuits","title":"Snowflurry.transpile","text":"transpile(transpiler::Transpiler, circuit::QuantumCircuit)::QuantumCircuit\n\nReturns a transpiled copy of the circuit. The transpilation process depends on the transpiler.\n\nThe following transpilers are available:\n\nSequentialTranspiler\nCompressSingleQubitGatesTranspiler\nCastSwapToCZGateTranspiler\nCastCXToCZGateTranspiler\nCastISwapToCZGateTranspiler\nCastToffoliToCXGateTranspiler\nCastRootZZToZ90AndCZGateTranspiler\nCastToPhaseShiftAndHalfRotationXTranspiler\nCastUniversalToRzRxRzTranspiler\nCastRxToRzAndHalfRotationXTranspiler\nSimplifyRxGatesTranspiler\nSwapQubitsForAdjacencyTranspiler\nSimplifyRzGatesTranspiler\nCompressRzGatesTranspiler\nRemoveSwapBySwappingGatesTranspiler\nSimplifyTrivialGatesTranspiler\nUnsupportedGatesTranspiler\nReadoutsAreFinalInstructionsTranspiler\nCircuitContainsAReadoutTranspiler\nReadoutsDoNotConflictTranspiler\nDecomposeSingleTargetSingleControlGatesTranspiler\nRejectNonNativeInstructionsTranspiler\nRejectGatesOnExcludedPositionsTranspiler\nRejectGatesOnExcludedConnectionsTranspiler\n\nExample\n\njulia> transpiler = CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.SequentialTranspiler","page":"Quantum Circuits","title":"Snowflurry.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpiler stages. Calling      transpile(::SequentialTranspiler,::QuantumCircuit) will apply each stage in sequence to the input circuit and return a transpiled output circuit. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = SequentialTranspiler([\n                        CompressSingleQubitGatesTranspiler(),\n                        CastToPhaseShiftAndHalfRotationXTranspiler()\n                    ]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 3,\n                    instructions = [\n                        sigma_x(1),\n                        sigma_y(1),\n                        control_x(2,3),\n                        phase_shift(1,π/3)\n                    ])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n\nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──P(-2.0944)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CompressSingleQubitGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.CompressSingleQubitGatesTranspiler","text":"CompressSingleQubitGatesTranspiler\n\nTranspiler stage which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single Universal gates in a new circuit. Gate ordering may differ when gates are applied to different qubits,  but the input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 3,\n                    instructions = [\n                        sigma_x(1)\n                        sigma_y(1)\n                        control_x(2,3)\n                        phase_shift(1,π/3)\n                    ])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n                                 \nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastSwapToCZGateTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastSwapToCZGateTranspiler","text":"CastSwapToCZGateTranspiler\n\nTranspiler stage which expands all Swap gates into CZ gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastCXToCZGateTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastCXToCZGateTranspiler","text":"CastCXToCZGateTranspiler\n\nTranspiler stage which expands all CX gates into CZ and Hadamard gates. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastISwapToCZGateTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastISwapToCZGateTranspiler","text":"CastISwapToCZGateTranspiler\n\nTranspiler stage which expands all ISwap and ISwapDagger gates into CZ gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap_dagger(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──x†──\n       |   \nq[2]:──x†──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Y_m90─────────────*────Y_m90────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z─────────────X_90────Z────────────X_90──\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastToffoliToCXGateTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastToffoliToCXGateTranspiler","text":"CastToffoliToCXGateTranspiler\n\nTranspiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 3, instructions = [toffoli(1, 2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3\n   bit_count: 3\nq[1]:──*──\n       |\nq[2]:──*──\n       |\nq[3]:──X──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──\n                       |                    |              |                    |  \nq[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──\n            |          |         |          |                                      \nq[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────\n                                                                                   \n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastRootZZToZ90AndCZGateTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastRootZZToZ90AndCZGateTranspiler","text":"CastRootZZToZ90AndCZGateTranspiler\n\nTranspiler stage which converts all RootZZ and RootZZDagger gates into Z90  (or ZM90) gates and a ControlZ gate. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastRootZZToZ90AndCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [root_zz(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──√ZZ──\n        |\nq[2]:──√ZZ──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──Z_90────────────*──\n                       |\nq[2]:──────────Z_90────Z──\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [root_zz_dagger(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──√ZZ†──\n        |\nq[2]:──√ZZ†──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──Z_m90─────────────*──\n                         |\nq[2]:───────────Z_m90────Z──\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler","text":"CastToPhaseShiftAndHalfRotationXTranspiler,\n\nTranspiler stage which converts all single-qubit gates in the input circuit into combinations of PhaseShift and RotationX with angle π/2 in the output circuit. For any gate in the input circuit, the number of gates in the output varies between zero and 5. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nFields\n\natol::Real – Absolute tolerance for the comparison of rotation angles (default = 1e-6).\n\nExamples\n\njulia> transpiler = CastToPhaseShiftAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──X_90────Z────X_m90──\n\nq[2]:──────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastUniversalToRzRxRzTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastUniversalToRzRxRzTranspiler","text":"CastUniversalToRzRxRzTranspiler\n\nTranspiler stage which finds Universal gates in an input circuit and casts them into a sequence of PhaseShift (P), RotationX (Rx) and PhaseShift (P) gates in a new circuit. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CastUniversalToRzRxRzTranspiler();\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 2,\n                    instructions = [universal(1, π/2, π/4, π/8)]\n                )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0, π/4, 0)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CastRxToRzAndHalfRotationXTranspiler","page":"Quantum Circuits","title":"Snowflurry.CastRxToRzAndHalfRotationXTranspiler","text":"CastRxToRzAndHalfRotationXTranspiler\n\nTranspiler stage which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates (Z90, X90, PhaseShift(θ), XM90, and ZM90) in a new circuit. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler=CastRxToRzAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(0.3927)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──\n                                                    \nq[2]:───────────────────────────────────────────────\n                                                    \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.SimplifyRxGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.SimplifyRxGatesTranspiler","text":"SimplifyRxGatesTranspiler\n\nTranspiler stage which finds RotationX gates in an input circuit and, based on their  angle theta, casts them to one of the right-angle RotationX gates  (SigmaX, X90, or XM90). In the case where theta≈0., the gate is removed. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nFields\n\natol::Real – Absolute tolerance for the comparison of rotation angles (default = 1e-6).\n\nExamples\n\njulia> transpiler = SimplifyRxGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(3.1416)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(0.0000)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.SwapQubitsForAdjacencyTranspiler","page":"Quantum Circuits","title":"Snowflurry.SwapQubitsForAdjacencyTranspiler","text":"SwapQubitsForAdjacencyTranspiler\n\nTranspiler stage which adds Swap gates around multi-qubit gates so that the  final Operator acts on adjacent qubits. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nFields\n\nconnectivity::AbstractConnectivity – Connectivity for the placement of Swap gates.\n\nExamples\n\njulia> transpiler = SwapQubitsForAdjacencyTranspiler(LineConnectivity(6));\n\njulia> circuit = QuantumCircuit(qubit_count = 6, instructions = [toffoli(4, 6, 1)])\nQuantum Circuit Object:\n   qubit_count: 6 \n   bit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \n   bit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.SimplifyRzGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.SimplifyRzGatesTranspiler","text":"SimplifyRzGatesTranspiler\n\nTranspiler stage which finds PhaseShift gates in an input circuit and, based on their  phase angle phi, casts them to one of the right-angle RotationZ gates (SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger). In the case where phi≈0., the  gate is removed. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)\n\nFields\n\natol::Real – Absolute tolerance for the comparison of rotation angles (default = 1e-6).\n\nExamples\n\njulia> transpiler = SimplifyRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(1.5708)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(3.1416)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CompressRzGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.CompressRzGatesTranspiler","text":"CompressRzGatesTranspiler\n\nTranspiler stage which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into a single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nExamples\n\njulia> transpiler = CompressRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_z(1), z_90(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────Z_90──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 3,\n                    instructions = [sigma_z(1), pi_8(1), control_x(2,3), z_minus_90(1)]\n                )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──Z────T─────────Z_m90──\n                             \nq[2]:────────────*───────────\n                 |           \nq[3]:────────────X───────────\n                             \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──P(2.3562)───────\n                       \nq[2]:───────────────*──\n                    |  \nq[3]:───────────────X──\n                       \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.RemoveSwapBySwappingGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.RemoveSwapBySwappingGatesTranspiler","text":"RemoveSwapBySwappingGatesTranspiler\n\nTransipler stage which removes the Swap gates from the circuit assuming all-to-all connectivity.\n\nwarning: The initial state must be the ground state!\nThis transpiler stage assumes that the input state is 0rangle^otimes N, where N is the number of qubits. The stage should not be used on sub-circuits where the input state is not 0rangle^otimes N.\n\nThis transpiler stage eliminates Swap gates by moving the gates preceding each Swap gate.\n\nExamples\n\njulia> transpiler = RemoveSwapBySwappingGatesTranspiler();\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 2,\n                    instructions = [hadamard(1), swap(1, 2), sigma_x(2)]\n                )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────☒───────\n            |       \nq[2]:───────☒────X──\n                    \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──────────\n               \nq[2]:──H────X──\n               \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.SimplifyTrivialGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.SimplifyTrivialGatesTranspiler","text":"SimplifyTrivialGatesTranspiler\n\nTranspiler stage which removes gates that have no effect on the state Ket (e.g. Identity) and parameterized gates with null parameters (e.g. rotation_x(target, 0.)). The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase). The tolerance used for Base.isapprox() in each case can be set by passing an optional argument to the transpiler (e.g. transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)).\n\nFields\n\natol::Real – Absolute tolerance for the comparison of rotation angles (default = 1e-6).\n\nExamples\n\njulia> transpiler = SimplifyTrivialGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [identity_gate(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──I──\n          \nq[2]:─────\n          \njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                             \njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.UnsupportedGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.UnsupportedGatesTranspiler","text":"UnsupportedGatesTranspiler\n\nTranspiler stage which throws a NotImplementedError if a Controlled gate that operates on more than two qubits is found.\n\nExamples\n\njulia> transpiler = UnsupportedGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [control_z(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──Z──\n          \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──Z──\n          \n\njulia> invalid_circuit = QuantumCircuit(\n               qubit_count = 4,\n               instructions = [controlled(hadamard(2), [1, 3])],\n           )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──*──\n       |  \nq[2]:──H──\n       |  \nq[3]:──*──\n          \nq[4]:─────\n          \n\njulia> transpiled_circuit = transpile(transpiler, invalid_circuit)\nERROR: NotImplementedError{Gate{Controlled{Snowflurry.Hadamard}}}(:Transpiler, Gate Object: Controlled{Snowflurry.Hadamard}\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.ReadoutsAreFinalInstructionsTranspiler","page":"Quantum Circuits","title":"Snowflurry.ReadoutsAreFinalInstructionsTranspiler","text":"ReadoutsAreFinalInstructionsTranspiler\n\nTranspiler stage which ensures that each Readout instruction is the last operation  on each qubit where readouts are present. It also verifies that repeated readouts  on the same qubit do not occur. An error is thrown if these verifications fail.  This transpiler stage leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = ReadoutsAreFinalInstructionsTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(\n                    qubit_count=2,\n                    instructions = [hadamard(1), readout(1,1), sigma_x(1)]\n                )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲────X──\n                    \nq[2]:───────────────\n                    \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: AssertionError: Cannot perform `Gate` following `Readout` on qubit: 1\n[...]\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──✲────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: AssertionError: Found multiple `Readouts` on qubit: 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.CircuitContainsAReadoutTranspiler","page":"Quantum Circuits","title":"Snowflurry.CircuitContainsAReadoutTranspiler","text":"CircuitContainsAReadoutTranspiler\n\nA transpiler stage which ensures that at least one Readout instruction is present in the QuantumCircuit. Otherwise, an error is thrown. This transpiler stage leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = CircuitContainsAReadoutTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: ArgumentError: QuantumCircuit is missing a `Readout`. Would not return any result.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.ReadoutsDoNotConflictTranspiler","page":"Quantum Circuits","title":"Snowflurry.ReadoutsDoNotConflictTranspiler","text":"ReadoutsDoNotConflictTranspiler\n\nTranspiler stage which ensures that each Readout instruction present in the QuantumCircuit does not have conflicting destination bits, Otherwise, an error is thrown.  This transpiler stage leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = ReadoutsDoNotConflictTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(2,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──✲───────\n               \nq[2]:───────✲──\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: ArgumentError: `Readouts` in `QuantumCircuit` have conflicting destination bit: 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler","page":"Quantum Circuits","title":"Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler","text":"DecomposeSingleTargetSingleControlGatesTranspiler\n\nTranspiler stage which finds single-control, single-target Controlled gates in an input circuit and casts them into a sequence of RotationZ (Rz), ControlX, Universal (U) and PhaseShift (P) gates in a new, equivalent circuit. For reference, see Nielsen and Chuang, \"Quantum Computation and Quantum Information\", p. 180. The input and output circuits perform the same operation on an arbitrary state Ket (up to a global phase).\n\nnote: Note\nIf a global phase is applied by the kernel of the Controlled gate on the target  qubit, this decomposition preserves it.\n\nFor instance, rotation_z(pi) and phase_shift(pi) kernels will yield results with a phase offset.\n\nExamples\n\njulia> transpiler = DecomposeSingleTargetSingleControlGatesTranspiler();\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 2,\n                    instructions = [sigma_x(1), controlled(rotation_z(2, pi), [1])]\n                )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────────*───────\n                |       \nq[2]:───────Rz(3.1416)──\n                        \njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────────────────*──────────────────────────────────────*───────────────────────────────────\n                           |                                      |                                   \nq[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                                                                                      \njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> simulate(transpiled_circuit)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n-0.0 + 0.0im\n0.7071067811865477 - 0.7071067811865474im\n0.0 + 0.0im\n\njulia> circuit = QuantumCircuit(\n                    qubit_count = 2,\n                    instructions = [sigma_x(1), controlled(phase_shift(2, pi), [1])]\n                )\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────────*──────\n                |      \nq[2]:───────P(3.1416)──\n                       \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────────────────*──────────────────────────────────────*─────────────────────────────────────P(1.5708)──\n                           |                                      |                                                \nq[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)───────────────\n                                                                                                                   \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> simulate(circuit)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.RejectNonNativeInstructionsTranspiler","page":"Quantum Circuits","title":"Snowflurry.RejectNonNativeInstructionsTranspiler","text":"RejectNonNativeInstructionsTranspiler\n\nTranspiler stage which throws a DomainError if a non-native Instruction is found in the circuit. The circuit remains unchanged if no error is thrown.\n\nSee is_native_instruction for additional information about native instructions.\n\nFields\n\nconnectivity::AbstractConnectivity – Connectivity which specifies the connections on                                       which two-qubit gates can be applied.\nnative_gates::Vector{DataType} – List of native gates. The gates that are native to the                                   Anyon QPUs are used by default.\n\nExamples\n\njulia> connectivity = LineConnectivity(4)\nLineConnectivity{4}\n1──2──3──4\n\n\njulia> default_transpiler = RejectNonNativeInstructionsTranspiler(connectivity);\n\n\njulia> invalid_circuit = QuantumCircuit(\n           qubit_count = 4,\n           instructions = [sigma_x(4), control_z(1, 3)],\n           )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:───────*──\n            |  \nq[2]:───────|──\n            |  \nq[3]:───────Z──\n               \nq[4]:──X───────\n               \n\njulia> transpile(default_transpiler, invalid_circuit)\nERROR: DomainError with LineConnectivity{4}\n1──2──3──4\n[...]\n\n\njulia> valid_circuit = QuantumCircuit(\n           qubit_count = 4,\n           instructions = [sigma_x(4), control_z(1, 2)],\n           )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:───────*──\n            |  \nq[2]:───────Z──\n               \nq[3]:──────────\n               \nq[4]:──X───────\n               \n\njulia> transpiled_circuit = transpile(default_transpiler, valid_circuit)\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:───────*──\n            |  \nq[2]:───────Z──\n               \nq[3]:──────────\n               \nq[4]:──X───────\n\n\njulia> custom_circuit = QuantumCircuit(\n                  qubit_count = 4,\n                  instructions = [control_x(2, 3)],\n                  )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:─────\n          \nq[2]:──*──\n       |  \nq[3]:──X──\n          \nq[4]:─────\n          \n\njulia> transpile(default_transpiler, custom_circuit)\nERROR: DomainError with LineConnectivity{4}\n1──2──3──4\n[...]\n\n\njulia> custom_transpiler = RejectNonNativeInstructionsTranspiler(\n            connectivity,\n            [Snowflurry.ControlX]\n        );\n\n\njulia> transpiled_circuit = transpile(custom_transpiler, custom_circuit)\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:─────\n          \nq[2]:──*──\n       |  \nq[3]:──X──\n          \nq[4]:─────\n          \n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.RejectGatesOnExcludedPositionsTranspiler","page":"Quantum Circuits","title":"Snowflurry.RejectGatesOnExcludedPositionsTranspiler","text":"RejectGatesOnExcludedPositionsTranspiler\n\nTranspiler stage which throws a DomainError if an Instruction in the circuit operates on an excluded qubit. The excluded qubits are specified with the parameter excluded_positions in certain AbstractConnectivity objects. The circuit remains unchanged if no error is thrown.\n\nFields\n\nconnectivity::AbstractConnectivity – Connectivity where the excluded_positions are                                       specified.\n\nExamples\n\njulia> excluded_positions = [2];\n\njulia> connectivity = LineConnectivity(4, excluded_positions)\nLineConnectivity{4}\n1──2──3──4\nexcluded positions: [2]\n\n\njulia> transpiler = RejectGatesOnExcludedPositionsTranspiler(connectivity);\n\njulia> invalid_circuit = QuantumCircuit(\n               qubit_count = 4,\n               instructions = [sigma_x(4), control_z(1, 2)],\n           )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:───────*──\n            |  \nq[2]:───────Z──\n               \nq[3]:──────────\n               \nq[4]:──X───────\n               \n\n\n\njulia> transpile(transpiler, invalid_circuit)\nERROR: DomainError with LineConnectivity{4}\n1──2──3──4\nexcluded positions: [2]\n:\nthe Gate{Snowflurry.ControlZ} on qubits [1, 2] cannot be applied since qubit 2 is unavailable\n[...]\n\njulia> valid_circuit = QuantumCircuit(\n               qubit_count = 4,\n               instructions = [sigma_x(1), control_z(3, 4)],\n           )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──X───────\n               \nq[2]:──────────\n               \nq[3]:───────*──\n            |  \nq[4]:───────Z──\n               \n\n\n\njulia> transpiled_circuit = transpile(transpiler, valid_circuit)\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──X───────\n               \nq[2]:──────────\n               \nq[3]:───────*──\n            |  \nq[4]:───────Z──\n               \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.RejectGatesOnExcludedConnectionsTranspiler","page":"Quantum Circuits","title":"Snowflurry.RejectGatesOnExcludedConnectionsTranspiler","text":"RejectGatesOnExcludedConnectionsTranspiler\n\nTranspiler stage which throws a DomainError if an Instruction in the circuit operates on an excluded connection. The excluded connections are specified with the parameter excluded_connections in certain AbstractConnectivity objects. The function returns the same circuit if no error is thrown.\n\nFields\n\nconnectivity::AbstractConnectivity – Connectivity where the excluded_connections are                                       specified.\n\nExamples\n\njulia> excluded_positions = Int[];\n\njulia> excluded_connections = [(2, 3)];\n\njulia> connectivity = LineConnectivity(4, excluded_positions, excluded_connections)\nLineConnectivity{4}\n1──2──3──4\nexcluded connections: [(2, 3)]\n\n\njulia> transpiler = RejectGatesOnExcludedConnectionsTranspiler(connectivity);\n\njulia> invalid_circuit = QuantumCircuit(\n                      qubit_count = 4,\n                      instructions = [sigma_x(4), control_z(3, 2)],\n                  )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──────────\n               \nq[2]:───────Z──\n            |  \nq[3]:───────*──\n               \nq[4]:──X───────\n               \n\n\n\njulia> transpile(transpiler, invalid_circuit)\nERROR: DomainError with LineConnectivity{4}\n1──2──3──4\nexcluded connections: [(2, 3)]\n:\nthe Gate{Snowflurry.ControlZ} on qubits [3, 2] cannot be applied since connection (2, 3) is unavailable\n[...]\n\njulia> valid_circuit = QuantumCircuit(\n                      qubit_count = 4,\n                      instructions = [sigma_x(1), control_z(3, 4)],\n                  )\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──X───────\n               \nq[2]:──────────\n               \nq[3]:───────*──\n            |  \nq[4]:───────Z──\n               \n\n\n\njulia> transpiled_circuit = transpile(transpiler, valid_circuit)\nQuantum Circuit Object:\n   qubit_count: 4 \n   bit_count: 4 \nq[1]:──X───────\n               \nq[2]:──────────\n               \nq[3]:───────*──\n            |  \nq[4]:───────Z──\n               \n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Snowflurry.compare_circuits","page":"Quantum Circuits","title":"Snowflurry.compare_circuits","text":"compare_circuits(c0::QuantumCircuit, c1::QuantumCircuit)::Bool\n\nTests for the equivalence of two QuantumCircuit objects based on their effect on an arbitrary input state (a Ket). The circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with gates that are applied in a different order and to different targets can also be equivalent. \n\nnote: Note\nIf there are Readout instructions present on either QuantumCircuit,  compare_circuits checks that both circuits have readouts targeting the same qubits and that no operations exist on those qubits after readout.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, instructions = [phase_shift(1, π)])\nQuantum Circuit Object:\n   qubit_count: 1  \n   bit_count: 1  \nq[1]:──P(3.1416)──\n                  \n\n\n\njulia> compare_circuits(c0, c1)\ntrue            \n\njulia> c0 = QuantumCircuit(\n                qubit_count = 3,\n                instructions = [sigma_x(1), sigma_y(1), control_x(2, 3)]\n            )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(\n                qubit_count = 3,\n                instructions = [control_x(2, 3), sigma_x(1), sigma_y(1)]\n            )\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0, c1)\ntrue    \n\njulia> c2 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), readout(1, 1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────✲──\n               \nq[2]:──────────\n               \nq[3]:──────────\n               \njulia> c3 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X──\n          \nq[2]:─────\n          \nq[3]:─────\n          \n\njulia> compare_circuits(c2,c3)\nfalse    \n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.circuit_contains_gate_type","page":"Quantum Circuits","title":"Snowflurry.circuit_contains_gate_type","text":"circuit_contains_gate_type(\n    circuit::QuantumCircuit,\n    gate_type::Type{<: AbstractGateSymbol}\n)::Bool\n\nDetermines if a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Snowflurry.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Snowflurry.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_display_symbols","page":"Quantum Circuits","title":"Snowflurry.get_display_symbols","text":"get_display_symbols(gate::AbstractGateSymbol; precision::Integer = 4,)::Vector{String}\n\nReturns a Vector{String} of the symbols that describe the gate.\n\nEach element in the Vector is associated with a qubit on which the gate operates. This is useful for the placement of the gate in a circuit diagram. The optional parameter precision enables setting the number of digits to keep after the decimal for gate parameters.\n\nExamples\n\njulia> get_display_symbols(get_gate_symbol(control_z(1, 2)))\n2-element Vector{String}:\n \"*\"\n \"Z\"\n\njulia> get_display_symbols(get_gate_symbol(phase_shift(1, π/2)), precision = 3)\n1-element Vector{String}:\n \"P(1.571)\"\n\n\n\n\n\n\nget_display_symbols(::Readout; precision::Integer = 4,)::Vector{String}\n\nReturns a Vector{String} of the symbols that describe the Readout.\n\nEach element in the Vector is associated with a qubit on which the Readout operates. This is useful for the placement of the Readout in a circuit diagram. The optional parameter precision has no effect for Readout.\n\nExamples\n\njulia> get_display_symbols(readout(2, 2))\n1-element Vector{String}:\n \"✲\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_instruction_symbol","page":"Quantum Circuits","title":"Snowflurry.get_instruction_symbol","text":"get_instruction_symbol(instruction::AbstractInstruction)::String\n\nReturns the symbol string that is associated with an instruction.\n\nExamples\n\njulia> get_instruction_symbol(control_z(1, 2))\n\"cz\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_symbol_for_instruction","page":"Quantum Circuits","title":"Snowflurry.get_symbol_for_instruction","text":"get_symbol_for_instruction(instruction::String)::DataType\n\nReturns a symbol given the corresponding String.\n\nExamples\n\njulia> get_symbol_for_instruction(\"cz\")\nSnowflurry.ControlZ\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.permute_qubits!","page":"Quantum Circuits","title":"Snowflurry.permute_qubits!","text":"permute_qubits!(\n    circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}\n) where T<:Integer\n\nModifies a circuit by moving the gates to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must be present as values and vice versa.\n\nFor instance, Dict(1 => 2) is not a valid qubit_mapping, but Dict(1 => 2, 2 => 1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──                    \n\n\n\njulia> permute_qubits!(c, Dict(1 => 3, 3 => 1))\n\njulia> show(c)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.permute_qubits","page":"Quantum Circuits","title":"Snowflurry.permute_qubits","text":"permute_qubits(\n    circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}\n)::QuantumCircuit where {T<:Integer}\n\nReturns a QuantumCircuit that is a copy of circuit but where the gates have been moved to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──\n                    \n\n\n\njulia> permute_qubits(c, Dict(1 => 3, 3 => 1))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n\n","category":"function"}]
}
