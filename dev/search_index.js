var documenterSearchIndex = {"docs":
[{"location":"tutorials/index.html#Tutorial","page":"Tutorials","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"If you want to know how Snowflake is used, this is the place to be.","category":"page"},{"location":"tutorials/index.html#Introductory-tutorials","page":"Tutorials","title":"Introductory tutorials","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"The introductory tutorials are the best place to start if you are new to quantum computation. These tutorials take you step by step through Snowflake, gradually introduce concepts and assume no prior quantum computation knowledge. We recommend you work through these tutorials in order to get the most out of them.","category":"page"},{"location":"tutorials/index.html#Get-QPU-metadata","page":"Tutorials","title":"Get QPU metadata","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we introduce the QPU interface and how to get the metadata of the machine.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/get_qpu_metadata.jl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: Get QPU metadata tutorial","category":"page"},{"location":"tutorials/index.html#Single-qubit-readout-fidelity","page":"Tutorials","title":"Single-qubit readout fidelity","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we cover the basics of initialization, readout, and readout fidelity.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/single_qubit_readout_fidelity.jl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: Single-qubit readout tutorial","category":"page"},{"location":"tutorials/index.html#Excitation-demonstration","page":"Tutorials","title":"Excitation demonstration","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we excite the qubit into state one.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/excitation_demonstration.jl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: Excitation demonstration","category":"page"},{"location":"tutorials/index.html#Hadamard-transpilation","page":"Tutorials","title":"Hadamard transpilation","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we introduce the hadamard gate and circuit transpilation.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/hadamard_transplation.jl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: Hadamard transpilation tutorial","category":"page"},{"location":"tutorials/index.html#Entanglement-demonstration","page":"Tutorials","title":"Entanglement demonstration","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we demonstrate entanglement by generating a Bell state.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/entanglement_demonstration.jl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: Entanglement demonstration tutorial","category":"page"},{"location":"tutorials/index.html#Advanced-tutorials","page":"Tutorials","title":"Advanced tutorials","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"More advanced uses are covered here.","category":"page"},{"location":"tutorials/index.html#Asyncronous-jobs","page":"Tutorials","title":"Asyncronous jobs","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we show how to run jobs asynchronously using Julia tasks.","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Code: tutorials/asynchronous_jobsjl","category":"page"},{"location":"tutorials/index.html","page":"Tutorials","title":"Tutorials","text":"Documentation: asynchronous jobs","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html#Asynchronous-jobs","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"","category":"section"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"This tutorial is going to how to run jobs asynchronously using Julia tasks. Asynchronous jobs allow users to continue other work while waiting for the quantum resources.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html#Julia-tasks","page":"Asynchronous jobs","title":"Julia tasks","text":"","category":"section"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"Communication with a quantum computer happens over a network. Any requests sent to a quantum computer are sent over the network. After the request is sent, we can only continue the job execution when we get a response from the quantum computer.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"If we absolutely have to have the job's result, we have no choice but to wait. Often, other work can be done while waiting for the quantum job to complete. We want to be able to continue with other work until we are ready to use the result. This type of control flow is called asynchronous control flow. We recommend you read Julia's page on asynchronous programming if you are unfamiliar with it.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"A quantum job communicating with a quantum computer will yield execution every time it waits for a response from the quantum computer. This gives you the opportunity to perform work while the quantum computer is running your job.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html#Code","page":"Asynchronous jobs","title":"Code","text":"","category":"section"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"To give you maximum flexibility, Snowflake does not impose any restrictions on how you parallelize your code. We cannot know what will be best for your code. That is up to you!","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"We will start by importing Snowflake, building our circuit, and defining our QPU. You can get more information on QPU objects at the Get QPU Metadata example tutorial.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"using Snowflake\n\ncircuit = QuantumCircuit(qubit_count=2, gates=[\n    hadamard(1),\n    control_x(1, 2),\n])\n\nuser = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"Next we are going to define and schedule our task.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"num_repetitions = 200\ntask = Task(() -> run_job(qpu, circuit, num_repetitions))\nschedule(task)","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"We must remember to schedule the task; otherwise, Julia will not know that it should start running your task! Next, we need to yield execution of the current thread to the newly scheduled task to ensure that the scheduler starts with the task. Otherwise, the task will be scheduled, but it might not submit a job to the quantum computer any time soon! After yielding once, we can continue to do work before we fetch the results from that task.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"yieldto(task)\n\n# Simulate work by calculating the nth Fibonacci number slowly\nfunction fibonacci(n)\n  if n <= 2\n    return 1\n  end\n  return fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nfibonacci(30)","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"After we are done with our work, we can fetch the result of our job.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"result = fetch(task)\nprintln(result)","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"The results show that our circuit was run, and we got the expected result!","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"Dict(\"00\" => 104, \"11\" => 96)","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html#Summary","page":"Asynchronous jobs","title":"Summary","text":"","category":"section"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"In this tutorial, we've gone over how to use asynchronous programming to do work while waiting for quantum jobs to complete.","category":"page"},{"location":"tutorials/advanced/asynchronous_jobs.html","page":"Asynchronous jobs","title":"Asynchronous jobs","text":"The full code is available at tutorials/asynchronous_jobs.jl","category":"page"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The following installation steps are for people interested in using Snowflake in their own applications. If you are interested in helping to develop Snowflake, head right over to our Developing Snowflake page.","category":"page"},{"location":"getting_started.html#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Make sure your system has Julia installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We officially support the latest stable release and the latest Long-term support release. Any release in-between should work (please file a bug if they don't), but we only actively test against the LTS and the latest stable version.","category":"page"},{"location":"getting_started.html#Installing-the-Snowflake-package","page":"Getting Started","title":"Installing the Snowflake package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Snowflake is still in pre-release phase. Therefore, and for the time being, we recommand installing it by checking out the main branch from github. This can be achieved by typing the following commands in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"This will add the Snowflake  package to the current Julia Environment.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Once Snowflake.jl is released, you can install the latest release using the following command:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"Snowflake\")","category":"page"},{"location":"getting_started.html#Installing-the-SnowflakePlots-package","page":"Getting Started","title":"Installing the SnowflakePlots package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Multiple visualization tools are available in the SnowflakePlots package. After installing Snowflake, the SnowflakePlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/SnowflakePlots.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html#Typical-workflow","page":"Getting Started","title":"Typical workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"A typical workflow to execute a quantum circuit on a quantum service consists of these three steps.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Create: Build the circuit using quantum gates.\nTranspile: Transpile the circuit to improve performance and make the circuit compatible with the quantum service.\nExecute: Run the compiled circuits on the specified quantum service. The quantum service could be a remote quantum hardware or a local simulator.","category":"page"},{"location":"getting_started.html#Create-a-Circuit","page":"Getting Started","title":"Create a Circuit","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Now, let's try Snowflake by making a two-qubit circuit which implements a Bell/EPR state. The quantum circuit for generating a Bell state involves a Hadamard gate on one of the qubits followed by a CNOT gate (see https://en.wikipedia.org/wiki/Quantumlogicgate for an introduction to quantum logic gates). This circuit is shown below:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"./images/bell_circuit.svg\"\n\t\ttitle=\"Bell state generator circuit\"\n\t\twidth=\"240\"\n\t/>\n</div>","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"First import Snowflake:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Snowflake","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"With Snowflake imported, we can define our two-qubit circuit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"c = QuantumCircuit(qubit_count=2)\nprint(c)\n\n# output\n\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:\n\nq[2]:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"In Snowflake, all qubits start in state left0rightrangle. Our circuit is, therefore,  in state left00rightrangle. We now proceed by adding gates to our circuit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"push!(c, hadamard(1))\npush!(c, control_x(1, 2))\n\nprint(c)\n\n# output\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──H────*──\n            |\nq[2]:───────X──","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The first line adds a Hadamard gate to circuit object c which will operate on qubit 1. The second line adds a CNOT gate (Control-X gate) with qubit 1 as the control qubit and qubit 2 as the target qubit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"getting_started.html#Simulate-your-circuit","page":"Getting Started","title":"Simulate your circuit","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The next step we want to take is to simulate our circuit. We do not need to transpile our circuit since our simulator can handle all gates, but for larger circuit you should consider transpilation to reduce the amount of work the simulator has to perform.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"ψ = simulate(c)\nprint(ψ)\n\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Finally, you can use SnowflakePlots to generate a histogram which shows the measurement output distribution after taking a certain number of shots, in this case 100, on a quantum computer simulator:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using SnowflakePlots\nplot_histogram(c, 100)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"(Image: Measurement results histogram)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The script below puts all the steps above together:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Snowflake, SnowflakePlots\n\nc = QuantumCircuit(qubit_count=2)\npush!(c, hadamard(1))\npush!(c, control_x(1, 2))\nψ = simulate(c)\n\nplot_histogram(ψ, 100)","category":"page"},{"location":"getting_started.html#Execute-on-Anyon's-hardware","page":"Getting Started","title":"Execute on Anyon's hardware","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Let's see how how to run the circuit created in the previous section on real hardawre.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We want to interact with Anyon's Quantum Computers, so we are going to construct an AnyonQPU. Three things are needed to construct an AnyonQPU. We need the username and access token to authenticate with the quantum computer and the hostname where the quantum computer can be found. The easiest way to get these parameters is by reading them from environment variables. For more information on QPU objects please go to Get QPU Metadata tutorial and Quantum Processing Unit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Let's see how to submit the circuit created in the previous section to a virtual or real hardware. ","category":"page"},{"location":"getting_started.html#Virtual-QPU","page":"Getting Started","title":"Virtual QPU","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We can use Snowflake to create a virtual QPU on our local machine:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"qpu = VirtualQPU()\nprint(qpu)\n\n# output\n\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflake.jl\n","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Because a virtual QPU can simulate any circuit as it is, we do not need to perform any transpilation or tests to run the jobs on the virtual QPU. Any circuit which is built using the gates in Snowflake can be run on the qpu for a given number of shots. ","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"shots_count=100\nresult=run_job(qpu, c,shots_count)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The result variable is a dictionary representing the histogram of the measurement results, with keys being the state vector, and values being the corresponding measurement counts:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"print(result)\nDict{String, Int64} with 2 entries:\n  \"00\" => 54\n  \"11\" => 46","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The above output shows that both qubits were measured to be in state '0' in 54 shots out of 100 tries on the virtual QPU. Similarly, both qubits were measured to be in state 1 for 46 shots out of 100 shots run on the QPU. We can achieve statistical convergence by increasing the shots_count and observe that outcomes are measured with equal probability.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The script below puts all the steps above together:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Snowflake\n\nqpu = VirtualQPU()\n\ncircuit = QuantumCircuit(qubit_count=2)\npush!(circuit, hadamard(1))\npush!(circuit, control_x(1, 2))\n\nnum_repetitions = 200\nresult = run_job(qpu, circuit, num_repetitions)\n","category":"page"},{"location":"getting_started.html#Hardware-QPU","page":"Getting Started","title":"Hardware QPU","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We can use Snowflake to submit a job to a real QPU:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)\nprint(qpu)\n\n# output\n\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6\n   connectivity_type:  linear","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Contraty to a virtual QPU, a physical QPU can only process a defined set of native gates. For any circuit that is contructed with Snowflake, a transpilation step is required, by which the circuit is converted into an equivalent one, but containing only gates that are native on the AnyonQPU. Optimization are also performed so that the total gate count is minimized.  ","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The circuit is transpiled and run on AnyonQPU with the following command:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"num_repetitions = 200\nresult = transpile_and_run_job(qpu, circuit, num_repetitions)\n\n# output\n","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"and the results are plotted with","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"plot_histogram(result)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"(Image: Measurement results histogram)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The script below puts all the steps above together:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Snowflake, SnowflakePlots\n\nuser = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)\n\ncircuit = QuantumCircuit(qubit_count=2)\npush!(circuit, hadamard(1))\npush!(circuit, control_x(1, 2))\n\nnum_repetitions = 200\nresult = transpile_and_run_job(qpu, circuit, num_repetitions)\n\nplot_histogram(result)","category":"page"},{"location":"getting_started.html#More-information","page":"Getting Started","title":"More information","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"For more information head over to our Tutorials page or our Library reference page.","category":"page"},{"location":"library.html#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = :(using Snowflake, SnowflakePlots)","category":"page"},{"location":"library.html#Quantum-Circuit","page":"Library","title":"Quantum Circuit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QuantumCircuit\npush!\npop!\nappend!\nprepend!\nsimulate\nsimulate_shots\nget_measurement_probabilities(circuit::QuantumCircuit)\ninv(circuit::QuantumCircuit)\nget_num_gates_per_type\nget_num_gates\nserialize_job\ntranspile\ncompare_circuits\ncircuit_contains_gate_type\npermute_qubits!\npermute_qubits","category":"page"},{"location":"library.html#Snowflake.QuantumCircuit","page":"Library","title":"Snowflake.QuantumCircuit","text":"QuantumCircuit(qubit_count)\n\nA data structure to represent a quantum circuit.  \n\nFields\n\nqubit_count::Int – number of qubits (i.e. quantum register size).\ngates::Vector{AbstractGate} – the sequence of gates to operate on qubits.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.push!","page":"Library","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gates::AbstractGate...)\n\nInserts one or more gates at the end of a circuit.\n\nA Vector of AbstractGate objects can be passed to this function by using splatting. More details about splatting are provided here.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> gate_list = [sigma_x(1), hadamard(2)];\n\njulia> push!(c, gate_list...)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*────X───────\n                 |            \nq[2]:───────X────X─────────H──\n                              \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.pop!","page":"Library","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last gate from circuit.gates. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.append!","page":"Library","title":"Base.append!","text":"append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)\n\nAppends one or more circuits_to_append to the base_circuit.\n\nThe circuits_to_append cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> append_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> append_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> append!(base, append_1, append_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Z────*──\n                 |  \nq[2]:────────────X──\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.prepend!","page":"Library","title":"Base.prepend!","text":"prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)\n\nPrepends one or more circuits_to_prepend to the base_circuit.\n\nThe order of the circuits_to_prepend is maintained (i.e. circuits_to_prepend[1] will appear leftmost in base_circuit). The circuits_to_prepend cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> prepend_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> prepend_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> prepend!(base, prepend_1, prepend_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────*────X──\n            |       \nq[2]:───────X───────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate","page":"Library","title":"Snowflake.simulate","text":"simulate(circuit::QuantumCircuit)\n\nSimulates and returns the wavefunction of the quantum device after running circuit,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  ψ=fock(0,2^get_num_qubits(circuit)). \n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate_shots","page":"Library","title":"Snowflake.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}])::AbstractVector{<:Real}\n\nReturns a vector listing the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.inv-Tuple{QuantumCircuit}","page":"Library","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.  Each gate is replaced by it's corresponding inverse, and the order of gates is reversed.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_gates_per_type","page":"Library","title":"Snowflake.get_num_gates_per_type","text":"get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{<:AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_gates","page":"Library","title":"Snowflake.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.serialize_job","page":"Library","title":"Snowflake.serialize_job","text":"serialize_job(circuit::QuantumCircuit,repetitions::Integer)\n\nCreates a JSON-formatted String containing the circuit configuration to be sent  to a QPU service, along with the number of repetitions requested.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> serialize_job(c,10)\n\"{\\\"num_repetitions\\\":10,\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}]}}\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.transpile","page":"Library","title":"Snowflake.transpile","text":"transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressSingleQubitGatesTranspiler transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single Universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n                                 \nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastSwapToCZGateTranspiler transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\ntranspile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastCXToCZGateTranspiler transpiler stage which expands all CX gates into CZ and Hadamard gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\ntranspile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastISwapToCZGateTranspiler transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\n\n\n\n\n\ntranspile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToffoliToCXGateTranspiler transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[toffoli(1, 2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3\nq[1]:──*──\n       |\nq[2]:──*──\n       |\nq[3]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──\n                       |                    |              |                    |  \nq[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──\n            |          |         |          |                                      \nq[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────\n                                                                                   \n\n\n\n\n\n\ntranspile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToPhaseShiftAndHalfRotationXTranspiler transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToPhaseShiftAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────Z────X_m90────Z_90──\n                                           \nq[2]:──────────────────────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastUniversalToRzRxRzTranspiler transpiler stage  which finds Universal gates in an input circuit and converst casts  them into a sequence of PhaseShift (Rz), RotationX (Rx) and  PhaseShift (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastUniversalToRzRxRzTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,π/2,π/4,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0,π/4,0)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n                                        \njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastRxToRzAndHalfRotationXTranspiler transpiler stage  which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates: Z90,X90,PhaseShift(θ),XM90,ZM90 in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastRxToRzAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.3927)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──\n                                                    \nq[2]:───────────────────────────────────────────────\n                                                    \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRxGatesTranspiler transpiler stage  which finds RotationX gates in an input circuit and according to it's  angle theta, casts them to one of the right-angle RotationX gates,  e.g. SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SimplifyRxGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(3.1416)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.0000)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SwapQubitsForLineConnectivityTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SwapQubitsForLineConnectivityTranspiler transpiler stage  which adds Swap gates around multi-qubit gates so that the  final Operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).\n\nExamples\n\njulia> transpiler=SwapQubitsForLineConnectivityTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRzGatesTranspiler transpiler stage  which finds PhaseShift gates in an input circuit and according to it's  phase angle phi, casts them to one of the right-angle RotationZ gates,  e.g. SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger. In the case where phi≈0., the  gate is removed. The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(1.5708)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(3.1416)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressRzGatesTranspiler transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_z(1),z_90(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────Z_90──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──Z────T─────────Z_m90──\n                             \nq[2]:────────────*───────────\n                 |           \nq[3]:────────────X───────────\n                             \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──P(2.3562)───────\n                       \nq[2]:───────────────*──\n                    |  \nq[3]:───────────────X──\n                       \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::RemoveSwapBySwappingGates, circuit::QuantumCircuit)::QuantumCircuit\n\nRemoves the Swap gates from the circuit assuming all-to-all connectivity.\n\nwarning: The initial state must be the ground state!\nThis transpiler stage assumes that the input state is 0rangle^otimes N where N is the number of qubits. The stage should not be used on sub-circuits where the input state is not 0rangle^otimes N.\n\nThis transpiler stage eliminates Swap gates by moving the gates preceding each Swap gate.\n\nExamples\n\njulia> transpiler = RemoveSwapBySwappingGates();\n\njulia> circuit = QuantumCircuit(qubit_count=2, gates=[hadamard(1), swap(1,2), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────☒───────\n            |       \nq[2]:───────☒────X──\n                    \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──────────\n               \nq[2]:──H────X──\n               \n\n\n\n\n\n\n\n\ntranspile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyTrivialGatesTranspiler transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyTrivialGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[identity_gate(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──I──\n          \nq[2]:─────\n          \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                             \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_circuits","page":"Library","title":"Snowflake.compare_circuits","text":"compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool\n\nTests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──P(3.1416)──\n                  \n\n\n\njulia> compare_circuits(c0,c1)\ntrue            \n\njulia> c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0,c1)\ntrue    \n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.circuit_contains_gate_type","page":"Library","title":"Snowflake.circuit_contains_gate_type","text":"circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{<:AbstractGate})::Bool\n\nDetermined whether or not a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.permute_qubits!","page":"Library","title":"Snowflake.permute_qubits!","text":"permute_qubits!(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}) where T<:Integer\n\nModifies a circuit by moving the gates to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──                    \n\n\n\njulia> permute_qubits!(c, Dict(1=>3, 3=>1))\n\njulia> show(c)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.permute_qubits","page":"Library","title":"Snowflake.permute_qubits","text":"permute_qubits(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where T<:Integer\n\nReturns a QuantumCircuit that is a copy of circuit but where the gates have been moved to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──\n                    \n\n\n\njulia> permute_qubits(c, Dict(1=>3, 3=>1))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Gates","page":"Library","title":"Quantum Gates","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AbstractGate\neye\nidentity_gate\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\npi_8\npi_8_dagger\nx_90\nx_minus_90\ny_90\ny_minus_90\nz_90\nz_minus_90\nrotation\nrotation_x\nrotation_y\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nswap\ntoffoli\niswap_dagger\nBase.:*(M::AbstractGate, x::Ket)\napply_gate!\nget_operator\ninv(gate::AbstractGate)\nis_gate_type\nget_gate_type\nmove_gate","category":"page"},{"location":"library.html#Snowflake.AbstractGate","page":"Library","title":"Snowflake.AbstractGate","text":"AbstractGate\n\nA Gate is an instantiation of an AbstractGate, which can be added to a QuantumCircuit in order to apply an operator to one or more target qubits. AbstractGate is useful to dispatch all Gates to default implementation of functions such as getconnectedqubits().  Those functions are then specialized for Gates requiring a different implementation. \n\nAbstractGate is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of Gate is a struct which is a subtype of AbstractGate. Each descendant of AbstractGate must have at least the following fields:\n\ntarget::Int: the qubit number to which the Gate is applied. Some gates have multiple targets.\nparameter::Real: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its Operator.\n\nExamples\n\nA struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:\n\njulia> struct X45 <: AbstractGate\n           target::Int\n       end;\n\n\nFor convenience, a constructor can be defined:\n\njulia> x_45(target::Integer) = X45(target);\n\n\nTo simulate the effect of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended.\n\njulia> Snowflake.get_operator(gate::X45, T::Type{<:Complex}=ComplexF64) = rotation_x(π/4, T);\n\n\nThe gate inverse can also be specified by extending the inv function.\n\njulia> inv(gate::X45) = rotation_x(gate.target, -π/4);\n\n\nAn instance of the X_45 gate can now be created:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Snowflake.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\nTo enable printout of a circuit containing our new gate type, a symbol  must be defined as follows.\n\njulia> Snowflake.gates_display_symbols[X45]=[\"X45\"];\n\n\nIf this gate is to be sent as an instruction to a hardware QPU,  an instruction string must be defined.\n\njulia> Snowflake.gates_instruction_symbols[X45]=\"x45\";\n\n\nA circuit containing this gate can now be constructed:\n\njulia> circuit=QuantumCircuit(qubit_count=2,gates=[x_45_gate])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──X45──\n\nq[2]:───────\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.eye","page":"Library","title":"Snowflake.eye","text":"eye(),\neye(size::Integer)\n\nReturn the identity matrix as a DenseOperator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\nCalling eye(size) will produce an identity matrix DenseOperator  of dimensions (size,size).\n\nExamples\n\njulia> eye()\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\njulia> eye(4)\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.identity_gate","page":"Library","title":"Snowflake.identity_gate","text":"identity_gate(target)\n\nReturn the Identity Gate, which applies the identity_gate() IdentityOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_p","page":"Library","title":"Snowflake.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_m","page":"Library","title":"Snowflake.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_x","page":"Library","title":"Snowflake.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_y","page":"Library","title":"Snowflake.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_z","page":"Library","title":"Snowflake.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.hadamard","page":"Library","title":"Snowflake.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8","page":"Library","title":"Snowflake.pi_8","text":"pi_8()\n\nReturn the Operator for the π/8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π/8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8_dagger","page":"Library","title":"Snowflake.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π/8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π/8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_90","page":"Library","title":"Snowflake.x_90","text":"x_90()\n\nReturn the Operator which applies a π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90° rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_minus_90","page":"Library","title":"Snowflake.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_90","page":"Library","title":"Snowflake.y_90","text":"y_90()\n\nReturn the Operator which applies a π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90° rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_minus_90","page":"Library","title":"Snowflake.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_90","page":"Library","title":"Snowflake.z_90","text":"z_90()\n\nReturn the Operator which applies a π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(fracpi2right) = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90° rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_minus_90","page":"Library","title":"Snowflake.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    1  0 \n    0  -i\n    endbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation","page":"Library","title":"Snowflake.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about the cos(phi)X+sin(phi)Y axis.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em      \n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the cos(phi)X+sin(phi)Y axis.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_x","page":"Library","title":"Snowflake.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em      \n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_y","page":"Library","title":"Snowflake.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em      \nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase_shift","page":"Library","title":"Snowflake.phase_shift","text":"phase_shift(phi)\n\nReturn the DiagonalOperator that applies a phase shift phi.\n\nThe DiagonalOperator is defined as:\n\nP(phi) = beginbmatrix\n    1  0 05em      \n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.universal","page":"Library","title":"Snowflake.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em      \n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_z","page":"Library","title":"Snowflake.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_x","page":"Library","title":"Snowflake.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap","page":"Library","title":"Snowflake.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.swap","page":"Library","title":"Snowflake.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.toffoli","page":"Library","title":"Snowflake.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap_dagger","page":"Library","title":"Snowflake.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{AbstractGate, Ket}","page":"Library","title":"Base.:*","text":"Base.:*(M::AbstractGate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1)*ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.apply_gate!","page":"Library","title":"Snowflake.apply_gate!","text":"apply_gate!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_gate!(ψ_0, sigma_x(1))\n\njulia> print(ψ_0)\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_operator","page":"Library","title":"Snowflake.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated to a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(x)\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.inv-Tuple{AbstractGate}","page":"Library","title":"Base.inv","text":"inv(gate::AbstractGate)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.is_gate_type","page":"Library","title":"Snowflake.is_gate_type","text":"is_gate_type(gate::AbstractGate, type::Type)::Bool\n\nDetermines if a gate is of the specified type.\n\nwarning: Use is_gate_type instead of isa!\nFor AbstractGate objects, is_gate_type should be used instead of isa. The utilization of isa could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> is_gate_type(gate, Snowflake.SigmaX)\ntrue\n\njulia> is_gate_type(gate, Snowflake.SigmaY)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_gate_type","page":"Library","title":"Snowflake.get_gate_type","text":"get_gate_type(gate::AbstractGate)::Type\n\nReturns the type of a gate.\n\nwarning: Use get_gate_type instead of typeof!\nFor AbstractGate objects, get_gate_type should be used instead of typeof. The utilization of typeof could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> get_gate_type(gate)\nSnowflake.SigmaX\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.move_gate","page":"Library","title":"Snowflake.move_gate","text":"move_gate(gate::AbstractGate,\n    qubit_mapping::AbstractDict{<:Integer,<:Integer})::AbstractGate\n\nReturns a copy of gate where the qubits on which the gate acts have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> move_gate(gate, Dict(1=>2))\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [2]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Processing-Unit","page":"Library","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AnyonQPU\nVirtualQPU\nClient\nget_host\nsubmit_circuit\nget_status\nget_result\nrun_job\ntranspile_and_run_job\nget_transpiler\nSequentialTranspiler","category":"page"},{"location":"library.html#Snowflake.AnyonQPU","page":"Library","title":"Snowflake.AnyonQPU","text":"AnyonQPU\n\nA data structure to represent a Anyon System's QPU.  \n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to rate-limit job status requests.\n\nExample\n\njulia>  qpu = AnyonQPU(host=\"example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6 \n   connectivity_type:  linear\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.VirtualQPU","page":"Library","title":"Snowflake.VirtualQPU","text":"VirtualQPU\n\nA data structure to represent a Quantum Simulator.  \n\nExample\n\njulia> qpu=VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflake.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Client","page":"Library","title":"Snowflake.Client","text":"Client\n\nA data structure to represent a Client to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n \n  \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.get_host","page":"Library","title":"Snowflake.get_host","text":"get_host(Client)\n\nReturns host URL of a Client to a QPU service.  \n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\");\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.submit_circuit","page":"Library","title":"Snowflake.submit_circuit","text":"submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)\n\nSubmit a circuit to a Client of QPU service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  \n\nExample\n\njulia> submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_status","page":"Library","title":"Snowflake.get_status","text":"get_status(client::Client,circuitID::String)::Dict{String, String}\n\nObtain the status of a circuit computation through a Client of a QPU service. Returns status::Dict containing status[\"type\"]:      -\"queued\"   : Computation in queue.     -\"running\"  : Computation being processed.     -\"failed\"   : QPU service has returned an error message.     -\"succeeded\": Computation is completed, result is available.\n\nIn the case of status[\"type\"]==\"failed\", the server error is contained in status[\"message\"].\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID)\nStatus: succeeded\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_result","page":"Library","title":"Snowflake.get_result","text":"get_result(client::Client,circuit::String)::Dict{String, Int}\n\nGet the histogram of a completed circuit calculation, through a Client of a QPU service,  by circuit identifier circuitID.\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID);\n\njulia> get_result(client,circuitID)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.run_job","page":"Library","title":"Snowflake.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)\n\nRun a circuit computation on a QPU simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\nrun_job(qpu::AnyonQPU, circuit::QuantumCircuit, num_repetitions::Integer)\n\nRun a circuit computation on a QPU service, repeatedly for the specified number of repetitions (num_repetitions).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.transpile_and_run_job","page":"Library","title":"Snowflake.transpile_and_run_job","text":"transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler,  or any other transpiler passed as a key-word argument.   The transpiled circuit is then run on a QPU simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\ntranspile_and_run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on the AnyonQPU, repeatedly for the specified number of repetitions (num_repetitions).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonQPU(client_anyon);\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_transpiler","page":"Library","title":"Snowflake.get_transpiler","text":"get_transpiler(qpu::AnyonQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForLineConnectivityTranspiler(), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6)])\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.SequentialTranspiler","page":"Library","title":"Snowflake.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpilerstages. Callingtranspile(::SequentialTranspiler,::QuantumCircuit)will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary stateKet` is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SequentialTranspiler([CompressSingleQubitGatesTranspiler(),CastToPhaseShiftAndHalfRotationXTranspiler()]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──  \n\nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──P(-2.0944)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Quantum-Toolkit","page":"Library","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library.html#Basic-Quantum-Objects","page":"Library","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Ket\nBra\nDiagonalOperator\nAntiDiagonalOperator\nDenseOperator\nBase.adjoint\nis_hermitian\nBase.exp(A::AbstractOperator)\nBase.getindex(A::AbstractOperator, m::Int64, n::Int64)\nexpected_value(A::AbstractOperator, psi::Ket)\nsparse\neigen\ntr\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nget_measurement_probabilities(x::Ket{Complex{T}}) where T<:Real\nket2dm\nfock_dm\nwigner\nmoyal\ngenlaguerre\nget_embed_operator\nget_num_qubits(x::AbstractOperator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\nspin_up\nspin_down\ncreate\ndestroy\nnumber_op\ncoherent\nShrodingerProblem{T<:AbstractOperator, S<:Complex}\nLindbladProblem{T<:DenseOperator}\nsesolve\nlindblad_solve\ncompare_kets","category":"page"},{"location":"library.html#Snowflake.Ket","page":"Library","title":"Snowflake.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  \n\nExamples\n\nAlthough NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflake\n\njulia> ψ = Ket([1.0; 0.0; 0.0])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\nA better way to initialize a Ket is to use a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Bra","page":"Library","title":"Snowflake.Bra","text":"A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DiagonalOperator","page":"Library","title":"Snowflake.DiagonalOperator","text":"A structure representing a diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the diagonal).\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.AntiDiagonalOperator","page":"Library","title":"Snowflake.AntiDiagonalOperator","text":"A structure representing a anti-diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).\n\nExamples\n\njulia> AntiDiagonalOperator([1,2])\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DenseOperator","page":"Library","title":"Snowflake.DenseOperator","text":"A structure representing a quantum operator with a full (dense) matrix representation.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2,-π/4)  \n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.adjoint","page":"Library","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.is_hermitian","page":"Library","title":"Snowflake.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e. self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.exp-Tuple{AbstractOperator}","page":"Library","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Library","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.expected_value-Tuple{AbstractOperator, Ket}","page":"Library","title":"Snowflake.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"library.html#SparseArrays.sparse","page":"Library","title":"SparseArrays.sparse","text":"sparse(x::AbstractOperator)\n\nReturns a SparseOperator representation of x.\n\nExamples\n\n```jldoctest julia> z = sparse(sigma_z()) (2, 2)-element Snowflake.SparseOperator: Underlying data ComplexF64:  1.0 + 0.0im        ⋅            ⋅       -1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.eigen","page":"Library","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.tr","page":"Library","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.kron","page":"Library","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.MultiBodySystem","page":"Library","title":"Snowflake.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.commute","page":"Library","title":"Snowflake.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x,σ_y)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.anticommute","page":"Library","title":"Snowflake.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x,σ_x)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.normalize!","page":"Library","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ=Ket([1.,2.,4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.\n\njulia> ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.ket2dm","page":"Library","title":"Snowflake.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock_dm","page":"Library","title":"Snowflake.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm=fock_dm(0,2)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.wigner","page":"Library","title":"Snowflake.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> using Printf\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: -0.561815\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.moyal","page":"Library","title":"Snowflake.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.genlaguerre","page":"Library","title":"Snowflake.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_embed_operator","page":"Library","title":"Snowflake.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3,2)\nSnowflake.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1=get_embed_operator(x,1,system)\n(8, 8)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{AbstractOperator}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0.\n                     0. 0.])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_bodies","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                     0. 0. 0.\n                     0. 0. 0.])\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_bodies-2","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock","page":"Library","title":"Snowflake.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith Fock basis of a Hilbert space with size hspace_size as a Ket.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_up","page":"Library","title":"Snowflake.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_down","page":"Library","title":"Snowflake.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.create","page":"Library","title":"Snowflake.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.destroy","page":"Library","title":"Snowflake.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.number_op","page":"Library","title":"Snowflake.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.coherent","page":"Library","title":"Snowflake.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0,20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20),ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.ShrodingerProblem","page":"Library","title":"Snowflake.ShrodingerProblem","text":"ShrodingerProblem is a structure that is defined to solve the shrodinger equation in time-domain using sesolve().\n\nFields\n\nH – a function that retrurns the  Hamiltonian operator (of any subtype of AbstractOperator) as a function of time.\ninit_state – initital state (Ket) of a quantum system\ntspan – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0\ne_ops – list of operators for which the expected value    (the observables) will be evaluated at each time step in t_range. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.LindbladProblem","page":"Library","title":"Snowflake.LindbladProblem","text":"A LindbladProblem is a structure that is defined to solve the Lindblad master equation in time-domain using lindblad_solve().\n\nFields\n\nH – a function that retrurns the  Hamiltonian operator (of any subtype of AbstractOperator) as a function of time.\ninit_state – initital state density matrix (DenseOperator) of a quantum system\ntspan – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0\ne_ops – list of operators (type DenseOperator) for which the expected value    (the observables) will be evaluated at each time step in t_range. \nc_ops – list of collapse operators (type DenseOperator). \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.sesolve","page":"Library","title":"Snowflake.sesolve","text":"sesolve(problem::ShrodingerProblem; kwargs...)\n\nSolves the Shrodinger equation:\n\nfracd Psid t=-i hatHPsi\n\nand returns a tuple correponding the time instance vector, the corresponding wavefunction Ket, and a Vector of observables evaluated at each time step. \n\nFields\n\nproblem – An object of type ShrodingerProblem that defines the problem to be solved. \nis_hamiltonian_static – A Bool variable indicating whether the Hamiltonian operator changes with time or not. Default value is false. If true, the solver can have significant performance boost.\nkwargs – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/commonsolveropts/#solver_options).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.lindblad_solve","page":"Library","title":"Snowflake.lindblad_solve","text":"    lindblad_solve(problem::LindbladProblem;kwargs...)\n\nSolves the Lindblad Master equation:\n\ndotrho=-i H rho+sum_i gamma_ileft(L_i rho L^dag_i - frac12leftL^dag_i L_i rhorightright)\n\nand returns a Vector of observables evaluated at each time step.\n\nFields\n\nproblem – An object of type LindbladProblem that defines the problem to be solved. \nkwargs – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/commonsolveropts/#solver_options)..\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_kets","page":"Library","title":"Snowflake.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1.,2.,3.,4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ=π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im*δ)*ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0,ψ_1)\ntrue\n\njulia> apply_gate!(ψ_1,sigma_x(1))\n\njulia> compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"The SnowflakePlots package provides multiple visualization tools for Snowflake.jl. Please see the documentation of SnowflakePlots for more details. ","category":"page"},{"location":"library.html#Pauli-Simulator","page":"Library","title":"Pauli Simulator","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"Snowflake provides tools for the efficient storage and manipulation of Pauli group elements.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Snowflake.PauliGroupElement\nget_pauli\nBase.:*(p1::Snowflake.PauliGroupElement, p2::Snowflake.PauliGroupElement)\nget_quantum_circuit\nget_negative_exponent\nget_imaginary_exponent","category":"page"},{"location":"library.html#Snowflake.PauliGroupElement","page":"Library","title":"Snowflake.PauliGroupElement","text":"PauliGroupElement\n\nA Pauli group element which is represented using the approach of Dehaene and De Moor (2003).\n\nThe get_pauli functions should be used to generate PauliGroupElement objects.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.get_pauli","page":"Library","title":"Snowflake.get_pauli","text":"get_pauli(circuit::QuantumCircuit; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a circuit containing Pauli gates.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. The Pauli operators are specified in the circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\n\nIf multiple Pauli gates are applied to the same qubit in the circuit, the gates are multiplied with the first gate in the circuit being the rightmost gate in the multiplication.\n\njulia> circuit = QuantumCircuit(qubit_count=1);\n\njulia> push!(circuit, sigma_x(1), sigma_z(1))\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Z──\n               \n\n\n\njulia> get_pauli(circuit)\nPauli Group Element:\n1.0im*Y(1)\n\n\n\n\n\n\n\n\nget_pauli(gate::AbstractGate, num_qubits::Integer; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a gate and the number of qubits.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. In this variant of the get_pauli function, a single Pauli operator is set by providing a gate. The number of qubits is specified by num_qubits.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> get_pauli(gate, num_qubits)\nPauli Group Element:\n1.0*X(2)\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{Snowflake.PauliGroupElement, Snowflake.PauliGroupElement}","page":"Library","title":"Base.:*","text":"Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement\n\nReturns the product of two PauliGroupElement objects.\n\nThe PauliGroupElement objects must be associated with the same number of qubits.\n\nExamples\n\njulia> pauli_z = get_pauli(sigma_z(1), 1)\nPauli Group Element:\n1.0*Z(1)\n\n\n\njulia> pauli_y = get_pauli(sigma_y(1), 1)\nPauli Group Element:\n1.0*Y(1)\n\n\n\njulia> pauli_z*pauli_y\nPauli Group Element:\n-1.0im*X(1)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_quantum_circuit","page":"Library","title":"Snowflake.get_quantum_circuit","text":"get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit\n\nReturns the Pauli gates of a PauliGroupElement as a QuantumCircuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> pauli = get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\njulia> get_quantum_circuit(pauli)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_negative_exponent","page":"Library","title":"Snowflake.get_negative_exponent","text":"get_negative_exponent(pauli::PauliGroupElement)::Int\n\nReturns the negative exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, negative_exponent=1)\nPauli Group Element:\n-1.0*X(2)\n\n\n\njulia> get_negative_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_imaginary_exponent","page":"Library","title":"Snowflake.get_imaginary_exponent","text":"get_imaginary_exponent(pauli::PauliGroupElement)::Int\n\nReturns the imaginary exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, imaginary_exponent=1)\nPauli Group Element:\n1.0im*X(2)\n\n\n\njulia> get_imaginary_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"development.html#Snowflake-development","page":"Developing","title":"Snowflake development","text":"","category":"section"},{"location":"development.html#Installing-Snowflake-for-local-development","page":"Developing","title":"Installing Snowflake for local development","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"When developing Snowflake, you must ensure that you are using a local copy of Snowflake, not the latest released version. The easiest way to achieve that is to set the project to the local directory.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you are starting a new instance of Julia, then you can activate the Snowflake project with","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Or, if you are inside a script or REPL, you can use","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If the current directory is not the Snowflake project, replace . with the Snowflake project path.","category":"page"},{"location":"development.html#Running-tests","page":"Developing","title":"Running tests","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL in the current project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"and run the tests","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.test()","category":"page"},{"location":"development.html#Build-the-documentation","page":"Developing","title":"Build the documentation","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL using the docs project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=./docs","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If it is the first time building the docs, you need to instantiate the Julia project and add the Snowflake project as a development dependency. This means the version of the Snowflake package loaded is the one at the path specified, pwd(), and not the one registered at JuliaHub.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.develop(PackageSpec(path=pwd()))\nPkg.instantiate()","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"At which point, the project status should be similar to the one below. The versions might be slightly different, but what is important is that the Status line refers to the docs/Project.toml and that Snowflake refers to <pwd()>/Snowflake.jl.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Pkg.status()\n\n# output\n      Status `<pwd()>/Snowflake.jl/docs/Project.toml`\n  [e30172f5] Documenter v0.27.24\n  [cd3eb016] HTTP v1.7.4\n  [682c06a0] JSON v0.21.4\n  [7bd9edc1] Snowflake v0.1.0 `<pwd()>/Snowflake.jl`\n  [90137ffa] StaticArrays v1.5.21\n  [2913bbd2] StatsBase v0.33.21\n  [de0858da] Printf","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Then you can run","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"include(\"./docs/make.jl\")","category":"page"},{"location":"development.html#Run-coverage-locally","page":"Developing","title":"Run coverage locally","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you haven't already, instantiate the project with Julia's package manager.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.Instantiate()'","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":".","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can run coverage locally from the project directory using","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. coverage.jl","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The script returns the covered and total line as output. An example output is shown below","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Covered lines: 1373\nTotal lines: 1383\nCoverage percentage: 0.9927693420101229","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html#Hadamard-transpilation-tutorial","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"","category":"section"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"This tutorial is going to introduce the Hadamard gate. Also, this tutorial demonstrates how to use a transpiler to run a non-native gate, the Hadamard gate, on Anyon's Quantum Computer.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html#Theory","page":"Hadamard transpilation tutorial","title":"Theory","text":"","category":"section"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"A hadamard gate is a 180° rotation around a tilted axis and is defined by the following unitary.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/hadamard_matrix.svg\"\n\t\ttitle=\"Hadamard matrix\"\n        style=\"transform: scale(0.5);\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"A Bloch sphere representation of a Hadamard gate applied to state zero is shown below.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/hadamard_bloch.svg\"\n\t\ttitle=\"Hadamard visualization visualization\"\n\t\twidth=\"240\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html#Code","page":"Hadamard transpilation tutorial","title":"Code","text":"","category":"section"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"We are going to start by importing Snowflake.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"using Snowflake\n\ncircuit = QuantumCircuit(qubit_count = 1)","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"We must now apply our Hadamard gate to our circuit.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"push!(circuit, hadamard(1))","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"Our circuit with the Hadamard-gate applied, and the implied measurement is shown below.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/hadamard_circuit.svg\"\n\t\ttitle=\"Hadamard circuit\"\n        style=\"transform: scale(2);\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"Now we want to run this tutorial on Anyon's Quantum computer. We need to construct an AnyonQPU object. You can get more information on QPU objects at the Get QPU Metadata tutorial.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"We cannot run our circuit directly on the QPU since the Hadamard gate is not a native gate of Anyon's Quantum Computer. The circuit first has to be transpiled. Transpilation is an object that can transform a circuit into a functionally equivalent circuit with a different form. To get a transpiler which can take an arbitrary circuit and transpile it into something that can run natively on a QPU, one has to use the get_transpiler on the QPU. With this transpiler, one can call the transpile function to transpile the circuit using the transpiler.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"transpiler = get_transpiler(qpu)\ntranspiled_circuit = transpile(transpiler, circuit)","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"The transpiled circuit is shown below.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/transpiled_hadamard_circuit.svg\"\n\t\ttitle=\"Transpiled Hadamard circuit\"\n        style=\"transform: scale(2);\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"Now we run our quantum circuit on Anyon's quantum computer!","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"num_repetitions = 200\nresult = run_job(qpu, transpiled_circuit, num_repetitions)\n\nprintln(result)","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"The results show that the samples are randomly distributed between state zero and state one.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"Dict(\"1\" => 109, \"0\" => 91)","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html#Summary","page":"Hadamard transpilation tutorial","title":"Summary","text":"","category":"section"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"In this tutorial, we've introduced the Hadamard gate. We've also demonstrated how to use a transpiler to transpile any circuit into a circuit which can be natively run on AnyonQPU.","category":"page"},{"location":"tutorials/introductory/hadamard_transpilation.html","page":"Hadamard transpilation tutorial","title":"Hadamard transpilation tutorial","text":"The full code for this tutorial is available at tutorials/hadamard_transplation.jl","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html#Single-qubit-readout-tutorial","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"","category":"section"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"This tutorial is going to show you how to construct a circuit and measure the circuit without any operations. During this tutorial, we will discuss initialization, readout, and readout fidelity.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"A Bloch sphere of a system in state zero is shown below.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/readout_zero_bloch.svg\"\n\t\ttitle=\"Zero-state readout visualization\"\n\t\twidth=\"240\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html#Code","page":"Single-qubit readout tutorial","title":"Code","text":"","category":"section"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"We are going to start by importing Snowflake.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"using Snowflake","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"This will bring all Snowflake's imports into the local scope for us to use. Next, we will create our circuit.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"circuit = QuantumCircuit(qubit_count = 1)","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"The circuit has no gates and consists and consists of one quantum register. In Snowflake, quantum registers always start initialized in state zero. The newly created circuit is shown below.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/empty_circuit.svg\"\n\t\ttitle=\"Empty circuit\"\n        style=\"transform: scale(2);\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"In Snowflake, circuits have an implied measurement operation at the end of the circuit. Other SDKs, such as Cirq and Qiskit, readout operations must be explicitly added to a circuit. The circuit with the readout drawn in is shown below.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/single_qubit_readout_circuit.svg\"\n\t\ttitle=\"Single-qubit readout circuit\"\n        style=\"transform: scale(2);\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"Now we want to run this tutorial on Anyon's Quantum computer. We need to construct an AnyonQPU object. You can get more information on QPU objects at the Get QPU Metadata tutorial.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"Now we run our quantum circuit on Anyon's quantum computer!","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"num_repetitions = 200\nresult = run_job(qpu, circuit, num_repetitions)\n\nprintln(result)","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"We have our first results! The results are stored in a dictionary where the keys are the states measured, and the values are how many times those states were measured.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"Dict(\"1\" => 3, \"0\" => 197)","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"When you run it yourself, you will see that you don't always get exactly the same result. Don't worry. This is what is expected. When reading out a result, you are sampling from a distribution. The randomness in the samples is what makes the result vary between runs.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"From the result, we can see that we have a very high estimated state preparation and readout fidelity of 98.5%! We can only estimate the true readout fidelity since we are sampling from a distribution. You might also be wondering why it is not 100%. In an analogue system, you cannot perfectly set and measure levels. Quantum systems are no different. In quantum systems, these errors are called State preparation and measurement (SPAM) errors.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html#Summary","page":"Single-qubit readout tutorial","title":"Summary","text":"","category":"section"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"In this tutorial, we've gone over how to construct and readout a single qubit circuit. We've discussed state initialization, readout fidelity, and state preparation and measurement errors.","category":"page"},{"location":"tutorials/introductory/single_qubit_readout_fidelity.html","page":"Single-qubit readout tutorial","title":"Single-qubit readout tutorial","text":"The full code for this tutorial is available at tutorials/single_qubit_readout_fidelity.jl","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html#Excitation-demonstration","page":"Excitation demonstration","title":"Excitation demonstration","text":"","category":"section"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"This tutorial is going to show a demonstration of how to excite a qubit into state left1rightrangle.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"A Bloch sphere of a system in state one is shown below.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/excitation_bloch.svg\"\n\t\ttitle=\"Excitation demonstration visualization\"\n\t\twidth=\"240\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html#Theory","page":"Excitation demonstration","title":"Theory","text":"","category":"section"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"We want to take our qubit from state zero to state one. To do this, we must perform a quantum gate. We call the gate we want to perform X. We can write down equations for our X gate. The X gate should take a qubit in state zero to state one and a qubit in state one into state zero.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/x_ket_equations.svg\"\n\t\ttitle=\"X-gate ket equations\"\n        style=\"transform: scale(0.5)\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"We can re-write out equations into matrix form.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/x_matrix_equations.svg\"\n\t\ttitle=\"X-gate matrix equations\"\n        style=\"transform: scale(0.5)\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"It is trivial to solve X as a matrix. ","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/x_matrix.svg\"\n\t\ttitle=\"X-gate matrix\"\n        style=\"transform: scale(0.5)\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"Quantum gates are also, in general, represented as matrices. On a single-qubit, a gate is a rotation around the Bloch sphere. The X-gate is a 180° rotation around the X-axis.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html#Code","page":"Excitation demonstration","title":"Code","text":"","category":"section"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"We are going to start by importing Snowflake and creating an empty circuit.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"using Snowflake\n\ncircuit = QuantumCircuit(qubit_count = 1)","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"We must now apply our X gate to our circuit.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"qubit = 1\npush!(circuit, sigma_x(qubit))","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"Our circuit with the X-gate applied, and the implied measurement is shown below.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"../../images/excitation_circuit.svg\"\n\t\ttitle=\"Excitation demonstration circuit\"\n        style=\"transform: scale(2)\"\n\t/>\n</div>","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"Now we want to run this tutorial on Anyon's Quantum computer. We need to construct an AnyonQPU object. You can get more information on QPU objects at the Get QPU Metadata tutorial.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"Now we run our quantum circuit on Anyon's quantum computer!","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"num_repetitions = 200\nresult = run_job(qpu, circuit, num_repetitions)\n\nprintln(result)","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"The results show an overwhelming majority of samples are in state one.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"Dict(\"1\" => 191, \"0\" => 9)","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html#Summary","page":"Excitation demonstration","title":"Summary","text":"","category":"section"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"In this tutorial, we've gone over how to excite a qubit into state one. We've explained that a single qubit gate is a rotation around the Bloch's sphere.","category":"page"},{"location":"tutorials/introductory/excitation_demonstration.html","page":"Excitation demonstration","title":"Excitation demonstration","text":"The full code is available at tutorials/excitation_demonstration.jl","category":"page"},{"location":"index.html#Snowflake.jl","page":"Home","title":"Snowflake.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, experiments and algorithms. Snowflake can run these quantum applications on real quantum computers or classical simulators.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nSnowflake has yet to reach version 1.0, but we intend to keep compatibility with what is documented here. We will only make a breaking change if something is broken. After version 1.0, the public API will be stable and only change with major releases.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html#Get-QPU-metadata-tutorial","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"","category":"section"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"using Snowflake\n\nDocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"This tutorial is going to teach you what a QPU object is. Also, we are going to show you how to construct an AnyonQPU object which can be used to interact with Anyon's quantum hardware. Finally, this tutorial will show you how to get metadata from a QPU object.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html#Code","page":"Get QPU metadata tutorial","title":"Code","text":"","category":"section"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"A QPU object is an object which implements the AbstractQPU interface. This interface gives you a unified way to write code that is agnostic of the quantum service you are using. The interface dictates how to get metadata about the QPU, how to run a quantum circuit on the QPU, and more. ","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"We are going to start by importing Snowflake.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"using Snowflake","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"Next, we are going to create the QPU object. We want to interact with Anyon's Quantum Computers, so we are going to construct an AnyonQPU. Three things are needed to construct an AnyonQPU. We need the username and access token to authenticate with the quantum computer and the hostname where the quantum computer can be found. The easiest way to get these parameters is by reading them from environment variables.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"When we have the environment variables, we can construct our AnyonQPU object.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"qpu = AnyonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"Now that we have an AnyonQPU object, we want to get the machine's metadata to see what we're dealing with. We do this using the get_metadata function.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"println(\"AnyonQPU metadata:\")\nfor (key,value) in get_metadata(qpu)\n    println(\"    $(key): $(value)\")\nend","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"After printing out all the metadata you should see something similar to what is shown below.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"Quantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6\n   connectivity_type:  linear","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html#Summary","page":"Get QPU metadata tutorial","title":"Summary","text":"","category":"section"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"In this tutorial, we've gone over what a QPU object is. We've also shown how to construct an AnyonQPU object and how to retrieve its metadata.","category":"page"},{"location":"tutorials/introductory/get_qpu_metadata.html","page":"Get QPU metadata tutorial","title":"Get QPU metadata tutorial","text":"The full code for this tutorial is available at tutorials/get_qpu_metadata.jl","category":"page"}]
}
