<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Circuits · Snowflurry</title><meta name="title" content="Quantum Circuits · Snowflurry"/><meta property="og:title" content="Quantum Circuits · Snowflurry"/><meta property="twitter:title" content="Quantum Circuits · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="Snowflurry logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="../tutorials/virtual_qpu.html">Virtual QPU</a></li><li><a class="tocitem" href="../tutorials/anyon_qpu.html">Real Hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../tutorials/advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="quantum_toolkit.html">Quantum Toolkit</a></li><li><a class="tocitem" href="quantum_gates.html">Quantum Gates</a></li><li class="is-active"><a class="tocitem" href="quantum_circuit.html">Quantum Circuits</a></li><li><a class="tocitem" href="qpu.html">QPU</a></li><li><a class="tocitem" href="pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/library/quantum_circuit.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.QuantumCircuit" href="#Snowflurry.QuantumCircuit"><code>Snowflurry.QuantumCircuit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(
    qubit_count::Int,
    bit_count::Int,
    instructions::Vector{AbstractInstruction},
    name::String = &quot;default&quot;
)
QuantumCircuit(circuit::QuantumCircuit)</code></pre><p>A data structure which describes a <em>quantum circuit</em>.</p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – Largest qubit index (e.g., specifying <code>qubit_count=n</code> enables the                       use of qubits 1 to n).</li><li><code>bit_count::Int</code> – Optional: Number of classical bits (i.e., result register size).                     Defaults to <code>qubit_count</code> if unspecified.</li><li><code>instructions::Vector{AbstractInstruction}</code> – Optional: Sequence of                                                <code>AbstractInstructions</code> (<code>Gates</code> and                                                <code>Readouts</code>) that operate on the qubits.                                                Defaults to an empty Vector.</li><li><code>name::String</code> – Optional: Name of the circuit and the corresponding job. It is used to                   identify the job when it is sent to a hardware or virtual QPU. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:</code></pre><p>A <code>QuantumCircuit</code> can be initialized with <a href="quantum_gates.html#Snowflurry.Gate"><code>Gate</code></a> and <a href="quantum_toolkit.html#Snowflurry.Readout"><code>Readout</code></a> structs:</p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(
            qubit_count = 2,
            instructions = [
                hadamard(1),
                sigma_x(2),
                control_x(1, 2),
                readout(1, 1),
                readout(2, 2)
            ])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────✲───────
                 |            
q[2]:───────X────X─────────✲──
                              </code></pre><p>A deep copy of a <code>QuantumCircuit</code> can be obtained with the following function:</p><pre><code class="language-julia-repl hljs">julia&gt; c_copy = QuantumCircuit(c)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────✲───────
                 |            
q[2]:───────X────X─────────✲──
                              </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L2-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_qubits" href="#Snowflurry.get_num_qubits"><code>Snowflurry.get_num_qubits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::AbstractOperator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 
                          0. 0.])
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/qobj.jl#L1140-L1157">source</a></section><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/qobj.jl#L1175-L1193">source</a></section><section><div><pre><code class="language-julia hljs">get_num_qubits(circuit::QuantumCircuit)::Int</code></pre><p>Returns the number of qubits in a <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; get_num_qubits(c)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L165-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_bits" href="#Snowflurry.get_num_bits"><code>Snowflurry.get_num_bits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_bits(circuit::QuantumCircuit)::Int</code></pre><p>Returns the number of classical bits in a <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2, bit_count=3);

julia&gt; get_num_bits(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L181-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_name" href="#Snowflurry.get_name"><code>Snowflurry.get_name</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_name(circuit::QuantumCircuit)::String</code></pre><p>Returns the name of the <code>circuit</code> and the corresponding job.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2, name = &quot;my_circuit&quot;);

julia&gt; get_name(c)
&quot;my_circuit&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L197-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_circuit_instructions" href="#Snowflurry.get_circuit_instructions"><code>Snowflurry.get_circuit_instructions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_circuit_instructions(circuit::QuantumCircuit)::Vector{AbstractInstruction}</code></pre><p>Returns the list of instructions in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), control_z(1, 2)]);

julia&gt; get_circuit_instructions(c)
2-element Vector{AbstractInstruction}:
 Gate Object: Snowflurry.Hadamard
Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.7071067811865475 + 0.0im    0.7071067811865475 + 0.0im
0.7071067811865475 + 0.0im    -0.7071067811865475 + 0.0im

 Gate Object: Snowflurry.ControlZ
Connected_qubits	: [1, 2]
Operator:
(4, 4)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    -1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L213-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gates::AbstractGateSymbol...)</code></pre><p>Inserts one or more <code>gates</code> at the end of a <code>circuit</code>.</p><p>A <code>Vector</code> of <code>AbstractGateSymbol</code> objects can be passed to this function by using splatting. More details about splatting are provided <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; gate_list = [sigma_x(1), hadamard(2)];

julia&gt; push!(c, gate_list...)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────X───────
                 |            
q[2]:───────X────X─────────H──
                              


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L248-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last instruction from <code>circuit.instructions</code>, and returns it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Gate Object: Snowflurry.ControlX
Connected_qubits	: [1, 2]
Operator:
(4, 4)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im

julia&gt; c
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L901-L952">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)</code></pre><p>Appends one or more <code>circuits_to_append</code> to the <code>base_circuit</code>.</p><p>The <code>circuits_to_append</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; append_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──Z──
          



julia&gt; append_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; append!(base, append_1, append_2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────Z────*──
                 |  
q[2]:────────────X──
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L313-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)</code></pre><p>Prepends one or more <code>circuits_to_prepend</code> to the <code>base_circuit</code>.</p><p>The order of the <code>circuits_to_prepend</code> is maintained (i.e., <code>circuits_to_prepend[1]</code> will appear leftmost in <code>base_circuit</code>). The <code>circuits_to_prepend</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; prepend_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──Z──
          



julia&gt; prepend_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; prepend!(base, prepend_1, prepend_2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────*────X──
            |       
q[2]:───────X───────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L382-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.update_circuit_qubit_count" href="#Snowflurry.update_circuit_qubit_count"><code>Snowflurry.update_circuit_qubit_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_circuit_qubit_count(
    quantum_cicuit::QuantumCircuit,
    qubit_count::Int,
)::QuantumCircuit</code></pre><p>Updates the <code>qubit_count</code> of the <code>quantum_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──X──
          



julia&gt; larger_circuit = update_circuit_qubit_count(circuit, 2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 1 
q[1]:──X──
          
q[2]:─────
          

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L104-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate" href="#Snowflurry.simulate"><code>Snowflurry.simulate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)::Ket</code></pre><p>Performs an ideal simulation of the <code>circuit</code> and returns the final quantum state (i.e. the wave function). The simulator assumes that the initial state <span>$\Psi$</span> corresponds to the zeroth Fock basis, i.e.: <code>ψ = fock(0, 2^get_num_qubits(circuit))</code>. The zeroth Fock basis corresponds to the initial state of most superconducting quantum processors, i.e.:</p><p class="math-container">\[|\Psi\rangle = |0\rangle^{\otimes n},\]</p><p>where <span>$n$</span> is the number of qubits.</p><div class="admonition is-info" id="Note-66cf0ab1c5a7e724"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-66cf0ab1c5a7e724" title="Permalink"></a></header><div class="admonition-body"><p>The input <code>circuit</code> must not include <code>Readout</code> instructions. Use     <a href="quantum_circuit.html#Snowflurry.simulate_shots"><code>simulate_shots</code></a> for the simulation of <code>circuits</code> with <code>Readout</code>     instructions.</p></div></div><p>The simulation utilizes the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1174-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate_shots" href="#Snowflurry.simulate_shots"><code>Snowflurry.simulate_shots</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results, as prescribed by the <code>Readout</code> instructions present in the circuit.  The distribution of measured states depends on the coefficients of the resulting state Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*────✲───────
            |            
q[2]:───────X─────────✲──


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1245-L1289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Snowflurry.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(
    circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}]
)::AbstractVector{&lt;:Real}</code></pre><p>Returns a list of the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <a href="quantum_circuit.html#Snowflurry.QuantumCircuit"><code>QuantumCircuit</code></a>, the probabilities are listed for <span>$\left|00\right\rangle$</span>, <span>$\left|01\right\rangle$</span>, <span>$\left|10\right\rangle$</span>, and <span>$\left|11\right\rangle$</span>.</p><div class="admonition is-info" id="Note-bdc3b84c05c60e23"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bdc3b84c05c60e23" title="Permalink"></a></header><div class="admonition-body"><p>By convention, qubit 1 is the leftmost bit, followed by every subsequent qubit.  The notation <span>$\left|10\right\rangle$</span> indicates that qubit 1 is in state <span>$\left|1\right\rangle$</span> and qubit 2 in state <span>$\left|0\right\rangle$</span>.</p></div></div><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring <span>$\left|10\right\rangle$</span> is 50% and the probability of measuring <span>$\left|11\right\rangle$</span> is also 50%:</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 2);

julia&gt; push!(circuit, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%:</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1420-L1475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.  Each gate is replaced by its corresponding inverse, and the order of gates is reversed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1490-L1525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates_per_type" href="#Snowflurry.get_num_gates_per_type"><code>Snowflurry.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(
    circuit::QuantumCircuit
)::AbstractDict{&lt;: AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction symbols of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1539-L1574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates" href="#Snowflurry.get_num_gates"><code>Snowflurry.get_num_gates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1590-L1616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.serialize_job" href="#Snowflurry.serialize_job"><code>Snowflurry.serialize_job</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,shot_count::Integer,host::String)</code></pre><p>Creates a JSON-formatted string that contains the circuit configuration that will be sent  to a <code>QPU</code> service. The URL for the <code>QPU</code> service corresponds to <code>host</code> while the number of circuit executions is equal to <code>shot_count</code>.</p><div class="admonition is-info" id="Note-81f8997d2139fdbd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-81f8997d2139fdbd" title="Permalink"></a></header><div class="admonition-body"><p>Qubit and bit indices use zero-based indexing in the JSON encoding.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(
            qubit_count = 2,
            instructions = [sigma_x(1)],
            name = &quot;sigma_x job&quot;
        )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          
julia&gt; serialize_job(c, 10, &quot;machine&quot;, &quot;project_id&quot;)
&quot;{\&quot;shotCount\&quot;:10,\&quot;name\&quot;:\&quot;sigma_x job\&quot;,\&quot;machineName\&quot;:\&quot;machine\&quot;,\&quot;projectID\&quot;:\&quot;project_id\&quot;,\&quot;type\&quot;:\&quot;circuit\&quot;,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}],\&quot;bitCount\&quot;:2,\&quot;qubitCount\&quot;:2}}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/anyon/qpu_interface.jl#L173-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.transpile" href="#Snowflurry.transpile"><code>Snowflurry.transpile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpile(transpiler::Transpiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Returns a transpiled copy of the <code>circuit</code>. The transpilation process depends on the <code>transpiler</code>.</p><p>The following transpilers are available:</p><ul><li><a href="quantum_circuit.html#Snowflurry.SequentialTranspiler"><code>SequentialTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CompressSingleQubitGatesTranspiler"><code>CompressSingleQubitGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastSwapToCZGateTranspiler"><code>CastSwapToCZGateTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastCXToCZGateTranspiler"><code>CastCXToCZGateTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastISwapToCZGateTranspiler"><code>CastISwapToCZGateTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastToffoliToCXGateTranspiler"><code>CastToffoliToCXGateTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastRootZZToZ90AndCZGateTranspiler"><code>CastRootZZToZ90AndCZGateTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler"><code>CastToPhaseShiftAndHalfRotationXTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastUniversalToRzRxRzTranspiler"><code>CastUniversalToRzRxRzTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CastRxToRzAndHalfRotationXTranspiler"><code>CastRxToRzAndHalfRotationXTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.SimplifyRxGatesTranspiler"><code>SimplifyRxGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.SwapQubitsForAdjacencyTranspiler"><code>SwapQubitsForAdjacencyTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.SimplifyRzGatesTranspiler"><code>SimplifyRzGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CompressRzGatesTranspiler"><code>CompressRzGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.RemoveSwapBySwappingGatesTranspiler"><code>RemoveSwapBySwappingGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.SimplifyTrivialGatesTranspiler"><code>SimplifyTrivialGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.UnsupportedGatesTranspiler"><code>UnsupportedGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.ReadoutsAreFinalInstructionsTranspiler"><code>ReadoutsAreFinalInstructionsTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.CircuitContainsAReadoutTranspiler"><code>CircuitContainsAReadoutTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.ReadoutsDoNotConflictTranspiler"><code>ReadoutsDoNotConflictTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler"><code>DecomposeSingleTargetSingleControlGatesTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.RejectNonNativeInstructionsTranspiler"><code>RejectNonNativeInstructionsTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.RejectGatesOnExcludedPositionsTranspiler"><code>RejectGatesOnExcludedPositionsTranspiler</code></a></li><li><a href="quantum_circuit.html#Snowflurry.RejectGatesOnExcludedConnectionsTranspiler"><code>RejectGatesOnExcludedConnectionsTranspiler</code></a></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L5-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SequentialTranspiler" href="#Snowflurry.SequentialTranspiler"><code>Snowflurry.SequentialTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SequentialTranspiler(Vector{&lt;:Transpiler})</code></pre><p>Composite transpiler object which is constructed from an array  of <code>Transpiler</code> stages. Calling      <code>transpile(::SequentialTranspiler,::QuantumCircuit)</code> will apply each stage in sequence to the input circuit and return a transpiled output circuit. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SequentialTranspiler([
                        CompressSingleQubitGatesTranspiler(),
                        CastToPhaseShiftAndHalfRotationXTranspiler()
                    ]);

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────H──
               
q[2]:──────────
               



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────X_90────Z_90────X_m90────Z──
                                                              
q[2]:───────────────────────────────────
                                                              



julia&gt; circuit = QuantumCircuit(
                    qubit_count = 3,
                    instructions = [
                        sigma_x(1),
                        sigma_y(1),
                        control_x(2,3),
                        phase_shift(1,π/3)
                    ])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────Y─────────P(1.0472)──

q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──P(-2.0944)───────
                        
q[2]:────────────────*──
                     |  
q[3]:────────────────X──
                        


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L63-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CompressSingleQubitGatesTranspiler" href="#Snowflurry.CompressSingleQubitGatesTranspiler"><code>Snowflurry.CompressSingleQubitGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompressSingleQubitGatesTranspiler</code></pre><p>Transpiler stage which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single <code>Universal</code> gates in a new circuit. Gate ordering may differ when gates are applied to different qubits,  but the input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 3,
                    instructions = [
                        sigma_x(1)
                        sigma_y(1)
                        control_x(2,3)
                        phase_shift(1,π/3)
                    ])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────Y─────────P(1.0472)──
                                 
q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L158-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastSwapToCZGateTranspiler" href="#Snowflurry.CastSwapToCZGateTranspiler"><code>Snowflurry.CastSwapToCZGateTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastSwapToCZGateTranspiler</code></pre><p>Transpiler stage which expands all Swap gates into <code>CZ</code> gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L505-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastCXToCZGateTranspiler" href="#Snowflurry.CastCXToCZGateTranspiler"><code>Snowflurry.CastCXToCZGateTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastCXToCZGateTranspiler</code></pre><p>Transpiler stage which expands all <code>CX</code> gates into <code>CZ</code> and <code>Hadamard</code> gates. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L568-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastISwapToCZGateTranspiler" href="#Snowflurry.CastISwapToCZGateTranspiler"><code>Snowflurry.CastISwapToCZGateTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastISwapToCZGateTranspiler</code></pre><p>Transpiler stage which expands all <code>ISwap</code> and <code>ISwapDagger</code> gates into <code>CZ</code> gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap_dagger(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──x†──
       |   
q[2]:──x†──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y_m90─────────────*────Y_m90────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z─────────────X_90────Z────────────X_90──
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L655-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastToffoliToCXGateTranspiler" href="#Snowflurry.CastToffoliToCXGateTranspiler"><code>Snowflurry.CastToffoliToCXGateTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastToffoliToCXGateTranspiler</code></pre><p>Transpiler stage which expands all Toffoli gates into <code>CX</code> gates and single-qubit gates. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastToffoliToCXGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions = [toffoli(1, 2, 3)])
Quantum Circuit Object:
   qubit_count: 3
   bit_count: 3
q[1]:──*──
       |
q[2]:──*──
       |
q[3]:──X──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──
                       |                    |              |                    |  
q[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──
            |          |         |          |                                      
q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────
                                                                                   
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L756-L789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastRootZZToZ90AndCZGateTranspiler" href="#Snowflurry.CastRootZZToZ90AndCZGateTranspiler"><code>Snowflurry.CastRootZZToZ90AndCZGateTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastRootZZToZ90AndCZGateTranspiler</code></pre><p>Transpiler stage which converts all <code>RootZZ</code> and <code>RootZZDagger</code> gates into <code>Z90</code>  (or <code>ZM90</code>) gates and a <code>ControlZ</code> gate. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastRootZZToZ90AndCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [root_zz(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──√ZZ──
        |
q[2]:──√ZZ──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──Z_90────────────*──
                       |
q[2]:──────────Z_90────Z──

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [root_zz_dagger(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──√ZZ†──
        |
q[2]:──√ZZ†──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──Z_m90─────────────*──
                         |
q[2]:───────────Z_m90────Z──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L815-L858">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler" href="#Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler"><code>Snowflurry.CastToPhaseShiftAndHalfRotationXTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastToPhaseShiftAndHalfRotationXTranspiler,</code></pre><p>Transpiler stage which converts all single-qubit gates in the input circuit into combinations of <code>PhaseShift</code> and <code>RotationX</code> with angle π/2 in the output circuit. For any gate in the input circuit, the number of gates in the output varies between zero and 5. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Fields</strong></p><ul><li><code>atol::Real</code> – Absolute tolerance for the comparison of rotation angles (default = 1e-6).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastToPhaseShiftAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──X_90────Z────X_m90──

q[2]:──────────────────────
                                           



julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L893-L982">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastUniversalToRzRxRzTranspiler" href="#Snowflurry.CastUniversalToRzRxRzTranspiler"><code>Snowflurry.CastUniversalToRzRxRzTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastUniversalToRzRxRzTranspiler</code></pre><p>Transpiler stage which finds <code>Universal</code> gates in an input circuit and casts them into a sequence of <code>PhaseShift</code> (P), <code>RotationX</code> (Rx) and <code>PhaseShift</code> (P) gates in a new circuit. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastUniversalToRzRxRzTranspiler();

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 2,
                    instructions = [universal(1, π/2, π/4, π/8)]
                )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0, π/4, 0)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1164-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CastRxToRzAndHalfRotationXTranspiler" href="#Snowflurry.CastRxToRzAndHalfRotationXTranspiler"><code>Snowflurry.CastRxToRzAndHalfRotationXTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CastRxToRzAndHalfRotationXTranspiler</code></pre><p>Transpiler stage which finds <code>RotationX(θ)</code> gates in an input circuit and converts (casts)  them into a sequence of gates (<code>Z90</code>, <code>X90</code>, <code>PhaseShift(θ)</code>, <code>XM90</code>, and <code>ZM90</code>) in a new circuit. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastRxToRzAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(0.3927)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──
                                                    
q[2]:───────────────────────────────────────────────
                                                    

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1279-L1313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SimplifyRxGatesTranspiler" href="#Snowflurry.SimplifyRxGatesTranspiler"><code>Snowflurry.SimplifyRxGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimplifyRxGatesTranspiler</code></pre><p>Transpiler stage which finds <code>RotationX</code> gates in an input circuit and, based on their  angle theta, casts them to one of the right-angle <code>RotationX</code> gates  (<code>SigmaX</code>, <code>X90</code>, or <code>XM90</code>). In the case where <code>theta≈0.</code>, the gate is removed. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Fields</strong></p><ul><li><code>atol::Real</code> – Absolute tolerance for the comparison of rotation angles (default = 1e-6).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyRxGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1345-L1429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SwapQubitsForAdjacencyTranspiler" href="#Snowflurry.SwapQubitsForAdjacencyTranspiler"><code>Snowflurry.SwapQubitsForAdjacencyTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SwapQubitsForAdjacencyTranspiler</code></pre><p>Transpiler stage which adds <code>Swap</code> gates around multi-qubit gates so that the  final <code>Operator</code> acts on adjacent qubits. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Fields</strong></p><ul><li><code>connectivity::AbstractConnectivity</code> – Connectivity for the placement of <code>Swap</code> gates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SwapQubitsForAdjacencyTranspiler(LineConnectivity(6));

julia&gt; circuit = QuantumCircuit(qubit_count = 6, instructions = [toffoli(4, 6, 1)])
Quantum Circuit Object:
   qubit_count: 6 
   bit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 6 
   bit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1467-L1524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SimplifyRzGatesTranspiler" href="#Snowflurry.SimplifyRzGatesTranspiler"><code>Snowflurry.SimplifyRzGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimplifyRzGatesTranspiler</code></pre><p>Transpiler stage which finds <code>PhaseShift</code> gates in an input circuit and, based on their  phase angle phi, casts them to one of the right-angle <code>RotationZ</code> gates (<code>SigmaZ</code>, <code>Z90</code>, <code>ZM90</code>, <code>Pi8</code> or <code>Pi8Dagger</code>). In the case where <code>phi≈0.</code>, the  gate is removed. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase). The tolerance  used for <code>Base.isapprox()</code> in each case can be set by passing an optional argument to the <code>Transpiler</code>, e.g: <code>transpiler=SimplifyRzGatesTranspiler(1.0e-10)</code></p><p><strong>Fields</strong></p><ul><li><code>atol::Real</code> – Absolute tolerance for the comparison of rotation angles (default = 1e-6).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(1.5708)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(3.1416)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1666-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CompressRzGatesTranspiler" href="#Snowflurry.CompressRzGatesTranspiler"><code>Snowflurry.CompressRzGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompressRzGatesTranspiler</code></pre><p>Transpiler stage which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into a single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CompressRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_z(1), z_90(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────Z_90──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.5708)──
                   
q[2]:──────────────
                   

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 3,
                    instructions = [sigma_z(1), pi_8(1), control_x(2,3), z_minus_90(1)]
                )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──Z────T─────────Z_m90──
                             
q[2]:────────────*───────────
                 |           
q[3]:────────────X───────────
                             

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──P(2.3562)───────
                       
q[2]:───────────────*──
                    |  
q[3]:───────────────X──
                       

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1787-L1850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.RemoveSwapBySwappingGatesTranspiler" href="#Snowflurry.RemoveSwapBySwappingGatesTranspiler"><code>Snowflurry.RemoveSwapBySwappingGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RemoveSwapBySwappingGatesTranspiler</code></pre><p>Transipler stage which removes the <code>Swap</code> gates from the <code>circuit</code> assuming all-to-all connectivity.</p><div class="admonition is-warning" id="The-initial-state-must-be-the-ground-state!-e9e81e6fc97e3701"><header class="admonition-header">The initial state must be the ground state!<a class="admonition-anchor" href="#The-initial-state-must-be-the-ground-state!-e9e81e6fc97e3701" title="Permalink"></a></header><div class="admonition-body"><p>This transpiler stage assumes that the input state is <span>$|0\rangle^{\otimes N}$</span>, where <span>$N$</span> is the number of qubits. The stage should not be used on sub-circuits where the input state is not <span>$|0\rangle^{\otimes N}$</span>.</p></div></div><p>This transpiler stage eliminates <code>Swap</code> gates by moving the gates preceding each <code>Swap</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = RemoveSwapBySwappingGatesTranspiler();

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 2,
                    instructions = [hadamard(1), swap(1, 2), sigma_x(2)]
                )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────☒───────
            |       
q[2]:───────☒────X──
                    



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──────────
               
q[2]:──H────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L1905-L1949">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SimplifyTrivialGatesTranspiler" href="#Snowflurry.SimplifyTrivialGatesTranspiler"><code>Snowflurry.SimplifyTrivialGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimplifyTrivialGatesTranspiler</code></pre><p>Transpiler stage which removes gates that have no effect on the state <code>Ket</code> (e.g. <code>Identity</code>) and parameterized gates with null parameters (e.g. <code>rotation_x(target, 0.)</code>). The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase). The tolerance used for <code>Base.isapprox()</code> in each case can be set by passing an optional argument to the transpiler (e.g. <code>transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)</code>).</p><p><strong>Fields</strong></p><ul><li><code>atol::Real</code> – Absolute tolerance for the comparison of rotation angles (default = 1e-6).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyTrivialGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [identity_gate(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──I──
          
q[2]:─────
          
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true


julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                             
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2002-L2079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.UnsupportedGatesTranspiler" href="#Snowflurry.UnsupportedGatesTranspiler"><code>Snowflurry.UnsupportedGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnsupportedGatesTranspiler</code></pre><p>Transpiler stage which throws a <code>NotImplementedError</code> if a <code>Controlled</code> gate that operates on more than two qubits is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = UnsupportedGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [control_z(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──Z──
          

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──Z──
          

julia&gt; invalid_circuit = QuantumCircuit(
               qubit_count = 4,
               instructions = [controlled(hadamard(2), [1, 3])],
           )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──*──
       |  
q[2]:──H──
       |  
q[3]:──*──
          
q[4]:─────
          

julia&gt; transpiled_circuit = transpile(transpiler, invalid_circuit)
ERROR: NotImplementedError{Gate{Controlled{Snowflurry.Hadamard}}}(:Transpiler, Gate Object: Controlled{Snowflurry.Hadamard}
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2143-L2191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.ReadoutsAreFinalInstructionsTranspiler" href="#Snowflurry.ReadoutsAreFinalInstructionsTranspiler"><code>Snowflurry.ReadoutsAreFinalInstructionsTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReadoutsAreFinalInstructionsTranspiler</code></pre><p>Transpiler stage which ensures that each <code>Readout</code> instruction is the last operation  on each qubit where readouts are present. It also verifies that repeated readouts  on the same qubit do not occur. An error is thrown if these verifications fail.  This transpiler stage leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = ReadoutsAreFinalInstructionsTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(
                    qubit_count=2,
                    instructions = [hadamard(1), readout(1,1), sigma_x(1)]
                )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲────X──
                    
q[2]:───────────────
                    

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: AssertionError: Cannot perform `Gate` following `Readout` on qubit: 1
[...]

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──✲────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: AssertionError: Found multiple `Readouts` on qubit: 1
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2208-L2267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.CircuitContainsAReadoutTranspiler" href="#Snowflurry.CircuitContainsAReadoutTranspiler"><code>Snowflurry.CircuitContainsAReadoutTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircuitContainsAReadoutTranspiler</code></pre><p>A transpiler stage which ensures that at least one <code>Readout</code> instruction is present in the <code>QuantumCircuit</code>. Otherwise, an error is thrown. This transpiler stage leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CircuitContainsAReadoutTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H──
          
q[2]:─────
          

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: ArgumentError: QuantumCircuit is missing a `Readout`. Would not return any result.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2307-L2349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.ReadoutsDoNotConflictTranspiler" href="#Snowflurry.ReadoutsDoNotConflictTranspiler"><code>Snowflurry.ReadoutsDoNotConflictTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReadoutsDoNotConflictTranspiler</code></pre><p>Transpiler stage which ensures that each <code>Readout</code> instruction present in the <code>QuantumCircuit</code> does not have conflicting destination bits, Otherwise, an error is thrown.  This transpiler stage leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = ReadoutsDoNotConflictTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(2,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──✲───────
               
q[2]:───────✲──
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: ArgumentError: `Readouts` in `QuantumCircuit` have conflicting destination bit: 1
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2371-L2413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler" href="#Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler"><code>Snowflurry.DecomposeSingleTargetSingleControlGatesTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DecomposeSingleTargetSingleControlGatesTranspiler</code></pre><p>Transpiler stage which finds single-control, single-target <code>Controlled</code> gates in an input circuit and casts them into a sequence of <code>RotationZ</code> (Rz), <code>ControlX</code>, <code>Universal</code> (U) and <code>PhaseShift</code> (P) gates in a new, equivalent circuit. For reference, see Nielsen and Chuang, &quot;Quantum Computation and Quantum Information&quot;, p. 180. The input and output circuits perform the same operation on an arbitrary state <code>Ket</code> (up to a global phase).</p><div class="admonition is-info" id="Note-f7b56c3aeb3fe728"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f7b56c3aeb3fe728" title="Permalink"></a></header><div class="admonition-body"><p>If a global phase is applied by the kernel of the <code>Controlled</code> gate on the target  qubit, this decomposition preserves it.</p></div></div><p>For instance, <code>rotation_z(pi)</code> and <code>phase_shift(pi)</code> kernels will yield results with a phase offset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = DecomposeSingleTargetSingleControlGatesTranspiler();

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 2,
                    instructions = [sigma_x(1), controlled(rotation_z(2, pi), [1])]
                )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────────*───────
                |       
q[2]:───────Rz(3.1416)──
                        
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X───────────────────*──────────────────────────────────────*───────────────────────────────────
                           |                                      |                                   
q[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                                                                                      
julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; simulate(transpiled_circuit)
4-element Ket{ComplexF64}:
0.0 + 0.0im
-0.0 + 0.0im
0.7071067811865477 - 0.7071067811865474im
0.0 + 0.0im

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 2,
                    instructions = [sigma_x(1), controlled(phase_shift(2, pi), [1])]
                )
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────────*──────
                |      
q[2]:───────P(3.1416)──
                       

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X───────────────────*──────────────────────────────────────*─────────────────────────────────────P(1.5708)──
                           |                                      |                                                
q[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)───────────────
                                                                                                                   

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; simulate(circuit)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2442-L2522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.RejectNonNativeInstructionsTranspiler" href="#Snowflurry.RejectNonNativeInstructionsTranspiler"><code>Snowflurry.RejectNonNativeInstructionsTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RejectNonNativeInstructionsTranspiler</code></pre><p>Transpiler stage which throws a <code>DomainError</code> if a non-native <code>Instruction</code> is found in the <code>circuit</code>. The <code>circuit</code> remains unchanged if no error is thrown.</p><p>See <a href="qpu.html#Snowflurry.is_native_instruction"><code>is_native_instruction</code></a> for additional information about native instructions.</p><p><strong>Fields</strong></p><ul><li>connectivity::AbstractConnectivity – Connectivity which specifies the connections on                                       which two-qubit gates can be applied.</li><li>native_gates::Vector{DataType} – List of native gates. The gates that are native to the                                   Anyon QPUs are used by default.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(4)
LineConnectivity{4}
1──2──3──4


julia&gt; default_transpiler = RejectNonNativeInstructionsTranspiler(connectivity);


julia&gt; invalid_circuit = QuantumCircuit(
           qubit_count = 4,
           instructions = [sigma_x(4), control_z(1, 3)],
           )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:───────*──
            |  
q[2]:───────|──
            |  
q[3]:───────Z──
               
q[4]:──X───────
               

julia&gt; transpile(default_transpiler, invalid_circuit)
ERROR: DomainError with LineConnectivity{4}
1──2──3──4
[...]


julia&gt; valid_circuit = QuantumCircuit(
           qubit_count = 4,
           instructions = [sigma_x(4), control_z(1, 2)],
           )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:───────*──
            |  
q[2]:───────Z──
               
q[3]:──────────
               
q[4]:──X───────
               

julia&gt; transpiled_circuit = transpile(default_transpiler, valid_circuit)
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:───────*──
            |  
q[2]:───────Z──
               
q[3]:──────────
               
q[4]:──X───────


julia&gt; custom_circuit = QuantumCircuit(
                  qubit_count = 4,
                  instructions = [control_x(2, 3)],
                  )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:─────
          
q[2]:──*──
       |  
q[3]:──X──
          
q[4]:─────
          

julia&gt; transpile(default_transpiler, custom_circuit)
ERROR: DomainError with LineConnectivity{4}
1──2──3──4
[...]


julia&gt; custom_transpiler = RejectNonNativeInstructionsTranspiler(
            connectivity,
            [Snowflurry.ControlX]
        );


julia&gt; transpiled_circuit = transpile(custom_transpiler, custom_circuit)
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:─────
          
q[2]:──*──
       |  
q[3]:──X──
          
q[4]:─────
          
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2595-L2712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.RejectGatesOnExcludedPositionsTranspiler" href="#Snowflurry.RejectGatesOnExcludedPositionsTranspiler"><code>Snowflurry.RejectGatesOnExcludedPositionsTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>RejectGatesOnExcludedPositionsTranspiler</p><p>Transpiler stage which throws a <code>DomainError</code> if an <code>Instruction</code> in the <code>circuit</code> operates on an excluded qubit. The excluded qubits are specified with the parameter <code>excluded_positions</code> in certain <code>AbstractConnectivity</code> objects. The <code>circuit</code> remains unchanged if no error is thrown.</p><p><strong>Fields</strong></p><ul><li>connectivity::AbstractConnectivity – Connectivity where the <code>excluded_positions</code> are                                       specified.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; excluded_positions = [2];

julia&gt; connectivity = LineConnectivity(4, excluded_positions)
LineConnectivity{4}
1──2──3──4
excluded positions: [2]


julia&gt; transpiler = RejectGatesOnExcludedPositionsTranspiler(connectivity);

julia&gt; invalid_circuit = QuantumCircuit(
               qubit_count = 4,
               instructions = [sigma_x(4), control_z(1, 2)],
           )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:───────*──
            |  
q[2]:───────Z──
               
q[3]:──────────
               
q[4]:──X───────
               



julia&gt; transpile(transpiler, invalid_circuit)
ERROR: DomainError with LineConnectivity{4}
1──2──3──4
excluded positions: [2]
:
the Gate{Snowflurry.ControlZ} on qubits [1, 2] cannot be applied since qubit 2 is unavailable
[...]

julia&gt; valid_circuit = QuantumCircuit(
               qubit_count = 4,
               instructions = [sigma_x(1), control_z(3, 4)],
           )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──X───────
               
q[2]:──────────
               
q[3]:───────*──
            |  
q[4]:───────Z──
               



julia&gt; transpiled_circuit = transpile(transpiler, valid_circuit)
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──X───────
               
q[2]:──────────
               
q[3]:───────*──
            |  
q[4]:───────Z──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2750-L2834">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.RejectGatesOnExcludedConnectionsTranspiler" href="#Snowflurry.RejectGatesOnExcludedConnectionsTranspiler"><code>Snowflurry.RejectGatesOnExcludedConnectionsTranspiler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RejectGatesOnExcludedConnectionsTranspiler</code></pre><p>Transpiler stage which throws a <code>DomainError</code> if an <code>Instruction</code> in the <code>circuit</code> operates on an excluded connection. The excluded connections are specified with the parameter <code>excluded_connections</code> in certain <code>AbstractConnectivity</code> objects. The function returns the same <code>circuit</code> if no error is thrown.</p><p><strong>Fields</strong></p><ul><li>connectivity::AbstractConnectivity – Connectivity where the <code>excluded_connections</code> are                                       specified.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; excluded_positions = Int[];

julia&gt; excluded_connections = [(2, 3)];

julia&gt; connectivity = LineConnectivity(4, excluded_positions, excluded_connections)
LineConnectivity{4}
1──2──3──4
excluded connections: [(2, 3)]


julia&gt; transpiler = RejectGatesOnExcludedConnectionsTranspiler(connectivity);

julia&gt; invalid_circuit = QuantumCircuit(
                      qubit_count = 4,
                      instructions = [sigma_x(4), control_z(3, 2)],
                  )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──────────
               
q[2]:───────Z──
            |  
q[3]:───────*──
               
q[4]:──X───────
               



julia&gt; transpile(transpiler, invalid_circuit)
ERROR: DomainError with LineConnectivity{4}
1──2──3──4
excluded connections: [(2, 3)]
:
the Gate{Snowflurry.ControlZ} on qubits [3, 2] cannot be applied since connection (2, 3) is unavailable
[...]

julia&gt; valid_circuit = QuantumCircuit(
                      qubit_count = 4,
                      instructions = [sigma_x(1), control_z(3, 4)],
                  )
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──X───────
               
q[2]:──────────
               
q[3]:───────*──
            |  
q[4]:───────Z──
               



julia&gt; transpiled_circuit = transpile(transpiler, valid_circuit)
Quantum Circuit Object:
   qubit_count: 4 
   bit_count: 4 
q[1]:──X───────
               
q[2]:──────────
               
q[3]:───────*──
            |  
q[4]:───────Z──
               

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/transpile.jl#L2885-L2970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.compare_circuits" href="#Snowflurry.compare_circuits"><code>Snowflurry.compare_circuits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit, c1::QuantumCircuit)::Bool</code></pre><p>Tests for the equivalence of two <a href="quantum_circuit.html#Snowflurry.QuantumCircuit"><code>QuantumCircuit</code></a> objects based on their effect on an arbitrary input state (a <code>Ket</code>). The circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with gates that are applied in a different order and to different targets can also be equivalent. </p><div class="admonition is-info" id="Note-b2c1304503014d2d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b2c1304503014d2d" title="Permalink"></a></header><div class="admonition-body"><p>If there are <code>Readout</code> instructions present on either <code>QuantumCircuit</code>,  <code>compare_circuits</code> checks that both circuits have readouts targeting the same qubits and that no operations exist on those qubits after readout.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, instructions = [phase_shift(1, π)])
Quantum Circuit Object:
   qubit_count: 1  
   bit_count: 1  
q[1]:──P(3.1416)──
                  



julia&gt; compare_circuits(c0, c1)
true            

julia&gt; c0 = QuantumCircuit(
                qubit_count = 3,
                instructions = [sigma_x(1), sigma_y(1), control_x(2, 3)]
            )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(
                qubit_count = 3,
                instructions = [control_x(2, 3), sigma_x(1), sigma_y(1)]
            )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0, c1)
true    

julia&gt; c2 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), readout(1, 1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────✲──
               
q[2]:──────────
               
q[3]:──────────
               
julia&gt; c3 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X──
          
q[2]:─────
          
q[3]:─────
          

julia&gt; compare_circuits(c2,c3)
false    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L454-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.circuit_contains_gate_type" href="#Snowflurry.circuit_contains_gate_type"><code>Snowflurry.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(
    circuit::QuantumCircuit,
    gate_type::Type{&lt;: AbstractGateSymbol}
)::Bool</code></pre><p>Determines if a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L605-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_display_symbols" href="#Snowflurry.get_display_symbols"><code>Snowflurry.get_display_symbols</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_display_symbols(gate::AbstractGateSymbol; precision::Integer = 4,)::Vector{String}</code></pre><p>Returns a <code>Vector{String}</code> of the symbols that describe the <code>gate</code>.</p><p>Each element in the <code>Vector</code> is associated with a qubit on which the <code>gate</code> operates. This is useful for the placement of the <code>gate</code> in a circuit diagram. The optional parameter <code>precision</code> enables setting the number of digits to keep after the decimal for <code>gate</code> parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_display_symbols(get_gate_symbol(control_z(1, 2)))
2-element Vector{String}:
 &quot;*&quot;
 &quot;Z&quot;

julia&gt; get_display_symbols(get_gate_symbol(phase_shift(1, π/2)), precision = 3)
1-element Vector{String}:
 &quot;P(1.571)&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L712-L734">source</a></section><section><div><pre><code class="language-julia hljs">get_display_symbols(::Readout; precision::Integer = 4,)::Vector{String}</code></pre><p>Returns a <code>Vector{String}</code> of the symbols that describe the <code>Readout</code>.</p><p>Each element in the <code>Vector</code> is associated with a qubit on which the <code>Readout</code> operates. This is useful for the placement of the <code>Readout</code> in a circuit diagram. The optional parameter <code>precision</code> has no effect for <code>Readout</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_display_symbols(readout(2, 2))
1-element Vector{String}:
 &quot;✲&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L771-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_instruction_symbol" href="#Snowflurry.get_instruction_symbol"><code>Snowflurry.get_instruction_symbol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_instruction_symbol(instruction::AbstractInstruction)::String</code></pre><p>Returns the symbol string that is associated with an <code>instruction</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_instruction_symbol(control_z(1, 2))
&quot;cz&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L835-L846">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_symbol_for_instruction" href="#Snowflurry.get_symbol_for_instruction"><code>Snowflurry.get_symbol_for_instruction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_symbol_for_instruction(instruction::String)::DataType</code></pre><p>Returns a symbol given the corresponding <code>String</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_symbol_for_instruction(&quot;cz&quot;)
Snowflurry.ControlZ
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L885-L896">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits!" href="#Snowflurry.permute_qubits!"><code>Snowflurry.permute_qubits!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute_qubits!(
    circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T}
) where T&lt;:Integer</code></pre><p>Modifies a <code>circuit</code> by moving the gates to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must be present as values and vice versa.</p><p>For instance, <code>Dict(1 =&gt; 2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1 =&gt; 2, 2 =&gt; 1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──                    



julia&gt; permute_qubits!(c, Dict(1 =&gt; 3, 3 =&gt; 1))

julia&gt; show(c)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1619-L1664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits" href="#Snowflurry.permute_qubits"><code>Snowflurry.permute_qubits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute_qubits(
    circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T}
)::QuantumCircuit where {T&lt;:Integer}</code></pre><p>Returns a <code>QuantumCircuit</code> that is a copy of <code>circuit</code> but where the gates have been moved to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──
                    



julia&gt; permute_qubits(c, Dict(1 =&gt; 3, 3 =&gt; 1))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/cde44309c1977983aa10deacb134facc2fea2855/src/core/quantum_circuit.jl#L1705-L1751">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quantum_gates.html">« Quantum Gates</a><a class="docs-footer-nextpage" href="qpu.html">QPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 24 October 2025 21:04">Friday 24 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
