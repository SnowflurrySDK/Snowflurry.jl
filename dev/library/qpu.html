<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QPU · Snowflurry</title><meta name="title" content="QPU · Snowflurry"/><meta property="og:title" content="QPU · Snowflurry"/><meta property="twitter:title" content="QPU · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="Snowflurry logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="../tutorials/virtual_qpu.html">Virtual QPU</a></li><li><a class="tocitem" href="../tutorials/anyon_qpu.html">Real Hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../tutorials/advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="quantum_toolkit.html">Quantum Toolkit</a></li><li><a class="tocitem" href="quantum_gates.html">Quantum Gates</a></li><li><a class="tocitem" href="quantum_circuit.html">Quantum Circuits</a></li><li class="is-active"><a class="tocitem" href="qpu.html">QPU</a></li><li><a class="tocitem" href="pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="qpu.html">QPU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="qpu.html">QPU</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/library/qpu.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.AnyonYukonQPU" href="#Snowflurry.AnyonYukonQPU"><code>Snowflurry.AnyonYukonQPU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnyonYukonQPU &lt;: AbstractQPU</code></pre><p>A data structure that describes an Anyon System QPU of the Yukon generation.  The QPU contains 6 qubits in a linear arrangement (see <a href="qpu.html#Snowflurry.LineConnectivity"><code>LineConnectivity</code></a>). </p><p><strong>Fields</strong></p><ul><li><code>client                  ::Client</code> – Client to the QPU server.</li><li><code>status_request_throttle ::Function</code> – Used to limit the rate of job status requests.</li><li><code>project_id              ::String</code> – Used to identify the project for the jobs that are sent to the QPU.</li><li><code>realm                   ::String</code> – Optional: Used to identify the host server realm for the submission of requests.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  qpu = AnyonYukonQPU(
            host = &quot;http://example.anyonsys.com&quot;,
            user = &quot;test_user&quot;,
            access_token = &quot;not_a_real_access_token&quot;,
            project_id = &quot;test-project&quot;,
            realm = &quot;test-realm&quot;
        )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    test-project
   qubit_count:   6 
   connectivity_type:  linear
   realm:         test-realm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.AnyonYamaskaQPU" href="#Snowflurry.AnyonYamaskaQPU"><code>Snowflurry.AnyonYamaskaQPU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnyonYamaskaQPU &lt;: AbstractQPU</code></pre><p>A data structure that describes an Anyon System QPU of the Yamaska generation.  The QPU contains 24 qubits in a 2D lattice arrangement (see <a href="qpu.html#Snowflurry.LatticeConnectivity"><code>LatticeConnectivity</code></a>).</p><p><strong>Fields</strong></p><ul><li><code>client                  ::Client</code> – Client to the QPU server.</li><li><code>status_request_throttle ::Function</code> – Used to limit the rate of job status requests.</li><li><code>project_id              ::String</code> – Used to identify the project for the jobs that are sent to the QPU.</li><li><code>realm                   ::String</code> – Optional: Used to identify the host server realm for the submission of requests.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  qpu = AnyonYamaskaQPU(
            host = &quot;http://example.anyonsys.com&quot;,
            user = &quot;test_user&quot;,
            access_token = &quot;not_a_real_access_token&quot;,
            project_id = &quot;test-project&quot;,
            realm = &quot;test-realm&quot;
        )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yamaska
   serial_number: ANYK202301
   project_id:    test-project
   qubit_count:   24 
   connectivity_type:  2D-lattice
   realm:         test-realm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L71-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.VirtualQPU" href="#Snowflurry.VirtualQPU"><code>Snowflurry.VirtualQPU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VirtualQPU</code></pre><p>The data structure for a quantum simulator.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = VirtualQPU()
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Snowflurry.jl

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L518-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.Client" href="#Snowflurry.Client"><code>Snowflurry.Client</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Client</code></pre><p>A data structure that represents a <em>client</em> for connection to a QPU service.  </p><p><strong>Fields</strong></p><ul><li><code>host::String</code> – URL of the QPU server.</li><li><code>user::String</code> – Username.</li><li><code>access_token::String</code> – User access token.</li><li><code>realm::String</code> – Optional: Used to identify the host server realm for the submission of requests.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(
            host = &quot;http://example.anyonsys.com&quot;,
            user = &quot;test_user&quot;,
            access_token = &quot;not_a_real_access_token&quot;,
            realm = &quot;test_realm&quot;
        )
Client for QPU service:
   host:         http://example.anyonsys.com
   user:         test_user 
   realm:        test_realm 
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L248-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_client" href="#Snowflurry.get_client"><code>Snowflurry.get_client</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_client(qpu_service::UnionAnyonQPU)</code></pre><p>Returns the client that is associated with the <code>qpu_service</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(
           host = &quot;http://example.anyonsys.com&quot;,
           user = &quot;test_user&quot;,
           access_token = &quot;not_a_real_access_token&quot;,
           project_id = &quot;test-project&quot;,
           realm = &quot;test-realm&quot;
       )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    test-project
   qubit_count:   6
   connectivity_type:  linear
   realm:         test-realm


julia&gt; get_client(qpu)
Client for QPU service:
   host:         http://example.anyonsys.com
   user:         test_user 
   realm:        test-realm 

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L149-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_project_id" href="#Snowflurry.get_project_id"><code>Snowflurry.get_project_id</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_project_id(qpu_service::UnionAnyonQPU)</code></pre><p>Returns the project ID that is associated with the <code>qpu_service</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(
           host = &quot;http://example.anyonsys.com&quot;,
           user = &quot;test_user&quot;,
           access_token = &quot;not_a_real_access_token&quot;,
           project_id = &quot;test-project&quot;,
           realm = &quot;test-realm&quot;
       )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    test-project
   qubit_count:   6
   connectivity_type:  linear
   realm:         test-realm


julia&gt; get_project_id(qpu)
&quot;test-project&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L184-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_host" href="#Snowflurry.get_host"><code>Snowflurry.get_host</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_host(Client)</code></pre><p>Returns the host URL of a <code>Client</code> for connection to a <code>QPU</code> service.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(
            host = &quot;http://example.anyonsys.com&quot;,
            user = &quot;test_user&quot;,
            access_token = &quot;not_a_real_access_token&quot;
        );

julia&gt; get_host(c)
&quot;http://example.anyonsys.com&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L291-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.submit_job" href="#Snowflurry.submit_job"><code>Snowflurry.submit_job</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">submit_job(
    client::Client,
    circuit::QuantumCircuit,
    shot_count::Integer,
    project_id::String,
    machine_name::String
)</code></pre><p>Use a <code>client</code> to submit a <code>circuit</code> to a QPU service on the host server.  The QPU service is specified by the <code>machine_name</code>. The number of circuit executions is specified by <code>shot_count</code>. </p><p>Returns the circuit ID, which can then be used when calling <a href="qpu.html#Snowflurry.get_status"><code>get_status</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(
            qubit_count = 3,
            instructions = [sigma_x(3), control_z(2, 1),
            readout(1, 1)]
        );

julia&gt; submit_job(client, circuit, 100, &quot;project_id&quot;, &quot;yukon&quot;)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L314-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.Status" href="#Snowflurry.Status"><code>Snowflurry.Status</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Status</code></pre><p>A data structure that stores the status of a quantum computation.  </p><p><strong>Fields</strong></p><ul><li><code>type::String</code> – One of the declared types, e.g.:<ul><li>&quot;QUEUED&quot;   : Computation in the queue.</li><li>&quot;RUNNING&quot;  : Computation being processed.</li><li>&quot;FAILED&quot;   : QPU service has returned an error message.</li><li>&quot;SUCCEEDED&quot;: Computation has succeeded, results are available.</li><li>&quot;CANCELLED&quot;: Computation was terminated before completion.</li></ul></li><li><code>message::String</code> – Optional: Message providing additional details about the computation   status.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_status_type" href="#Snowflurry.get_status_type"><code>Snowflurry.get_status_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_status_type(s::Status)::String</code></pre><p>Returns the type associated with the <code>Status</code> of a quantum computation.</p><p>See <a href="qpu.html#Snowflurry.Status"><code>Status</code></a> for more details about possible <code>type</code> strings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_status_type(Status(type = &quot;SUCCEEDED&quot;))
&quot;SUCCEEDED&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_status_message" href="#Snowflurry.get_status_message"><code>Snowflurry.get_status_message</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_status_message(s::Status)::String</code></pre><p>Returns the message associated with the <code>Status</code> of a quantum computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_status_message(Status(type = &quot;FAILED&quot;, message = &quot;something failed&quot;))
&quot;something failed&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_status" href="#Snowflurry.get_status"><code>Snowflurry.get_status</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_status(client::Client,circuitID::String)::Tuple{Status,Dict{String,Int}}</code></pre><p>Obtain the status of a circuit computation which uses a <code>client</code> for connection to a <code>QPU</code> service. See <a href="qpu.html#Snowflurry.Status"><code>Status</code></a> for more details about possible statuses.</p><p>In the case of status[&quot;type&quot;]==&quot;FAILED&quot;, the server error is contained in status[&quot;message&quot;].</p><p>In the case of status[&quot;type&quot;]==&quot;SUCCEEDED&quot;, the second element in the return tuple is  the histogram of the job results, as computed on the <code>QPU</code>, and the third element is the  job&#39;s execution time on the <code>QPU</code>, in milliseconds. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(
            qubit_count = 3,
            instructions = [sigma_x(3), control_z(2, 1),
            readout(1, 1)]
        );

julia&gt; jobID = submit_job(submit_job_client, circuit, 100, &quot;project_id&quot;, &quot;yukon&quot;)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(submit_job_client, jobID)
(Status: SUCCEEDED
, Dict(&quot;001&quot; =&gt; 100), 542)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L377-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.read_response_body" href="#Snowflurry.read_response_body"><code>Snowflurry.read_response_body</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_response_body(body::Base.CodeUnits{UInt8,String})::String</code></pre><p>Returns a <code>String</code> from Unicode code units.</p><p>See the <a href="https://docs.julialang.org/en/v1/base/strings/#lib-strings">Julia documentation</a> for more details about code units.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; string = &quot;my string&quot;
&quot;my string&quot;

julia&gt; body = codeunits(string)
9-element Base.CodeUnits{UInt8, String}:
 0x6d
 0x79
 0x20
 0x73
 0x74
 0x72
 0x69
 0x6e
 0x67

julia&gt; read_response_body(body)
&quot;my string&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L556-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.run_job" href="#Snowflurry.run_job"><code>Snowflurry.run_job</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_job(qpu::VirtualQPU, circuit::QuantumCircuit, shot_count::Integer)</code></pre><p>Execute a circuit on a <code>QPU</code> simulator. The number of circuit executions is specified by <code>shot_count</code>.</p><p>Returns a histogram of the circuit measurement outcomes as prescribed by the <code>Readout</code> instructions in the <code>circuit</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = VirtualQPU();

julia&gt; circuit = QuantumCircuit(
            qubit_count = 3,
            instructions = [
                sigma_x(3),
                control_z(2, 1),
                readout(1, 1),
                readout(2, 2),
                readout(3, 3)
            ]
        );

julia&gt; run_job(qpu, circuit, 100)
(Dict(&quot;001&quot; =&gt; 100), 147)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L643-L671">source</a></section><section><div><pre><code class="language-julia hljs">run_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit, shot_count::Integer)</code></pre><p>Submit a circuit to a <code>QPU</code> service for execution. The function does not perform the standard transpilation as in <a href="qpu.html#Snowflurry.transpile_and_run_job"><code>transpile_and_run_job</code></a>. The number of circuit executions is specified by <code>shot_count</code>.</p><p>Returns a histogram of the circuit measurement outcomes along with the  simulation&#39;s execution time (in milliseconds) or an error message.</p><p>If the <code>circuit</code> is invalid, it is not sent to the host and an error is thrown. The <code>circuit</code> can be invalid for the following reasons:</p><ul><li>The <code>circuit</code> contains no <code>Readout</code> instructions (see   <a href="quantum_circuit.html#Snowflurry.CircuitContainsAReadoutTranspiler"><code>CircuitContainsAReadoutTranspiler</code></a>).</li><li>Multiple <code>Readout</code> instructions have the same destination bits (see   <a href="quantum_circuit.html#Snowflurry.ReadoutsDoNotConflictTranspiler"><code>ReadoutsDoNotConflictTranspiler</code></a>).</li><li>The <code>Readout</code> instructions are not the last operation on each qubit where a readout is   present (see <a href="quantum_circuit.html#Snowflurry.ReadoutsAreFinalInstructionsTranspiler"><code>ReadoutsAreFinalInstructionsTranspiler</code></a>).</li><li>The <code>circuit</code> contains a <code>Controlled</code> gate that operates on more than two qubits (see   <a href="quantum_circuit.html#Snowflurry.UnsupportedGatesTranspiler"><code>UnsupportedGatesTranspiler</code></a>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(client, &quot;project_id&quot;)
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    project_id
   qubit_count:   6 
   connectivity_type:  linear
   realm:         test-realm

julia&gt; circuit = QuantumCircuit(
            qubit_count = 3,
            instructions = [sigma_x(3), control_z(2, 1), readout(1, 1)]
        );

julia&gt; run_job(qpu, circuit, 100)
(Dict(&quot;001&quot; =&gt; 100), 542)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L785-L828">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.transpile_and_run_job" href="#Snowflurry.transpile_and_run_job"><code>Snowflurry.transpile_and_run_job</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpile_and_run_job(
    qpu::VirtualQPU,
    circuit::QuantumCircuit,
    shot_count::Integer;
    transpiler::Transpiler = get_transpiler(qpu)
)</code></pre><p>This method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a keyword argument. The transpiled circuit is then executed on a <code>QPU</code> simulator, where the number of circuit executions is specified by <code>shot_count</code>.</p><p>Returns the histogram of the circuit measurement outcomes, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = VirtualQPU();

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 3,
                    instructions = [
                        sigma_x(3),
                        control_z(2, 1),
                        readout(1, 1),
                        readout(2, 2),
                        readout(3, 3)
                    ]);

julia&gt; transpile_and_run_job(qpu, circuit,100)
(Dict(&quot;001&quot; =&gt; 100), 132)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L597-L630">source</a></section><section><div><pre><code class="language-julia hljs">transpile_and_run_job(
    qpu::UnionAnyonQPU,
    circuit::QuantumCircuit,
    shot_count::Integer;
    transpiler::Transpiler = get_transpiler(qpu)
)</code></pre><p>This method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a keyword argument. The transpiled circuit is then submitted for execution on an Anyon QPU. The number of circuit executions is specified by <code>shot_count</code>.</p><p>Returns the histogram of the circuit measurement outcomes along with the job&#39;s  execution time on the <code>QPU</code> (in milliseconds), or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(client_anyon, &quot;project_id&quot;);

julia&gt; circuit = QuantumCircuit(
                    qubit_count = 3,
                    instructions = [
                        sigma_x(3),
                        control_z(2, 1),
                        readout(3, 3)
                    ]);

julia&gt; transpile_and_run_job(qpu, circuit, 100)
(Dict(&quot;001&quot; =&gt; 100), 542)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L739-L772">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_transpiler" href="#Snowflurry.get_transpiler"><code>Snowflurry.get_transpiler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_transpiler(qpu::AbstractQPU)::Transpiler</code></pre><p>Returns the transpiler associated with this QPU.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(client, &quot;project_id&quot;);

julia&gt; get_transpiler(qpu)
SequentialTranspiler(Transpiler[CircuitContainsAReadoutTranspiler(), ReadoutsDoNotConflictTranspiler(), UnsupportedGatesTranspiler(), DecomposeSingleTargetSingleControlGatesTranspiler(), CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), CastRootZZToZ90AndCZGateTranspiler(), SwapQubitsForAdjacencyTranspiler(LineConnectivity{6}
1──2──3──4──5──6
), CastSwapToCZGateTranspiler()  …  SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6), ReadoutsAreFinalInstructionsTranspiler(), RejectNonNativeInstructionsTranspiler(LineConnectivity{6}
1──2──3──4──5──6
, DataType[Snowflurry.Identity, Snowflurry.PhaseShift, Snowflurry.Pi8, Snowflurry.Pi8Dagger, Snowflurry.SigmaX, Snowflurry.SigmaY, Snowflurry.SigmaZ, Snowflurry.X90, Snowflurry.XM90, Snowflurry.Y90, Snowflurry.YM90, Snowflurry.Z90, Snowflurry.ZM90, Snowflurry.ControlZ]), RejectGatesOnExcludedPositionsTranspiler(LineConnectivity{6}
1──2──3──4──5──6
), RejectGatesOnExcludedConnectionsTranspiler(LineConnectivity{6}
1──2──3──4──5──6
)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L925-L946">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.AllToAllConnectivity" href="#Snowflurry.AllToAllConnectivity"><code>Snowflurry.AllToAllConnectivity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllToAllConnectivity &lt;:AbstractConnectivity</code></pre><p>A data structure which describes the all-to-all qubit connectivity of an Anyon Systems QPU. This connectivity type is encountered in simulated <code>QPUs</code> such as the <a href="qpu.html#Snowflurry.VirtualQPU"><code>VirtualQPU</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = AllToAllConnectivity()
AllToAllConnectivity()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L483-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.LineConnectivity" href="#Snowflurry.LineConnectivity"><code>Snowflurry.LineConnectivity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineConnectivity &lt;:AbstractConnectivity</code></pre><p>A data structure which describes the linear qubit connectivity of an Anyon System&#39;s QPU. This connectivity type is encountered in <code>QPUs</code> such as the <a href="qpu.html#Snowflurry.AnyonYukonQPU"><code>AnyonYukonQPU</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>dimension         ::Int</code> – Number of qubits for this connectivity.</li><li><code>excluded_positions::Vector{Int}</code> – Optional: List of qubits on the connectivity which                                      are disabled and cannot perform operations. Elements                                      in <code>Vector</code> must be unique.</li><li><code>excluded_connections::Vector{Tuple{Int, Int}}</code> – Optional: List of connections between                                                    qubits which are disabled and cannot                                                    perform 2-qubit gates. Elements in                                                    <code>Vector</code> must be unique. Each                                                    connection is provided as a <code>Tuple</code> of                                                    qubit indices.</li></ul><div class="admonition is-info" id="Note-776bd73ec49acd50"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-776bd73ec49acd50" title="Permalink"></a></header><div class="admonition-body"><p>Every excluded connection is sorted in ascending order (i.e. connection (2, 1) will be changed to (1, 2)).</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(6)
LineConnectivity{6}
1──2──3──4──5──6

julia&gt; connectivity = LineConnectivity(6, [1,2,3], [(3, 2), (3, 4)])
LineConnectivity{6}
1──2──3──4──5──6
excluded positions: [1, 2, 3]
excluded connections: [(2, 3), (3, 4)]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.LatticeConnectivity" href="#Snowflurry.LatticeConnectivity"><code>Snowflurry.LatticeConnectivity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeConnectivity &lt;:AbstractConnectivity</code></pre><p>A data structure which describes the two-dimensional lattice qubit connectivity of an Anyon System&#39;s QPU. This connectivity type is encountered in <code>QPUs</code> such as the <a href="qpu.html#Snowflurry.AnyonYamaskaQPU"><code>AnyonYamaskaQPU</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>qubits_per_printout_line::Vector{Int}</code> – Number of qubits in each line when constructing                                            the printout.</li><li><code>dimensions              ::Vector{Int}</code> – Number of rows and columns (turned 45° in the                                            printout).</li><li><code>excluded_positions      ::Vector{Int}</code> – Optional: List of qubits on the connectivity                                            which are disabled and cannot perform                                            operations. Elements in <code>Vector</code> must be                                            unique.</li><li><code>excluded_connections::Vector{Tuple{Int, Int}}</code> – Optional: List of connections between                                                    qubits which are disabled and cannot                                                    perform 2-qubit gates. Elements in                                                    <code>Vector</code> must be unique. Each                                                    connection is provided as a <code>Tuple</code> of                                                    qubit indices.</li></ul><p><strong>Example</strong></p><p>The following lattice has 3 rows, where each row has 4 elements. The rows contain qubits  <code>[1, 2, 3, 4]</code>, <code>[ 5, 6, 7, 8]</code>, and <code>[9, 10, 11, 12]</code>.</p><p>The corresponding <code>qubits_per_printout_line</code> field is <code>[1, 3, 3, 3, 2]</code>. It contains the number of qubits in each line of the printed representation.</p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LatticeConnectivity(3, 4)
LatticeConnectivity{3,4}
        1 
        | 
  9 ──  5 ──  2 
        |     | 
       10 ──  6 ──  3 
              |     | 
             11 ──  7 ──  4 
                    |     | 
                   12 ──  8 

</code></pre><p>Lattices of arbitrary dimensions can be built:</p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LatticeConnectivity(6, 4)
LatticeConnectivity{6,4}
              1 
              | 
        9 ──  5 ──  2 
        |     |     | 
 17 ── 13 ── 10 ──  6 ──  3 
  |     |     |     |     | 
 21 ── 18 ── 14 ── 11 ──  7 ──  4 
        |     |     |     |     | 
       22 ── 19 ── 15 ── 12 ──  8 
              |     |     | 
             23 ── 20 ── 16 
                    | 
                   24 </code></pre><p>Optionally, lattices with excluded positions can be defined:</p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LatticeConnectivity(3, 4, [1, 5, 9])
LatticeConnectivity{3,4}
        1 
        | 
  9 ──  5 ──  2 
        |     | 
       10 ──  6 ──  3 
              |     | 
             11 ──  7 ──  4 
                    |     | 
                   12 ──  8 

excluded positions: [1, 5, 9]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L126-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_excluded_connections" href="#Snowflurry.get_excluded_connections"><code>Snowflurry.get_excluded_connections</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_excluded_connections(
    connectivity::Union{LineConnectivity,LatticeConnectivity}
)::ExcludedConnections</code></pre><p>Returns the list of <code>excluded_connections</code> for the <code>connectivity</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L461-L467">source</a></section><section><div><pre><code class="language-julia hljs">get_excluded_connections(connectivity::AbstractConnectivity)::Vector{Tuple{Int, Int}}</code></pre><p>Throws a NotImplementedError.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_excluded_positions" href="#Snowflurry.get_excluded_positions"><code>Snowflurry.get_excluded_positions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_excluded_positions(
    c::Union{LineConnectivity,LatticeConnectivity}
)::Vector{Tuple{Int, Int}}</code></pre><p>Returns the list of <code>excluded_positions</code> for the connectivity.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_excluded_positions(LatticeConnectivity(3, 4, [1, 3]))
2-element Vector{Int64}:
 1
 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L434-L449">source</a></section><section><div><pre><code class="language-julia hljs">get_excluded_positions(connectivity::AbstractConnectivity)::Vector{Tuple{Int, Int}}</code></pre><p>Throws a NotImplementedError.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L453-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.path_search" href="#Snowflurry.path_search"><code>Snowflurry.path_search</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">path_search(
    origin::Int,
    target::Int,
    connectivity::AbstractConnectivity,
    excluded::Vector{Int} = Vector{Int}([])
)::Vector{Int}</code></pre><p>Find the shortest path between origin and target qubits in terms of  Manhattan distance. The path is found for any <code>connectivity::AbstractConnectivity</code> using the Breadth-first search algorithm. Positions that are specified in the  <code>excluded</code> optional argument are avoided. If no path exists, returns an empty <code>Vector{Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(6)
LineConnectivity{6}
1──2──3──4──5──6


julia&gt; path = path_search(2, 5, connectivity)
4-element Vector{Int64}:
 5
 4
 3
 2
</code></pre><p>For <a href="qpu.html#Snowflurry.LatticeConnectivity"><code>LatticeConnectivity</code></a>, the <a href="qpu.html#Snowflurry.print_connectivity"><code>print_connectivity()</code></a> method is used to visualize the path. The qubits along the path between origin and target are marked with <code>( )</code></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LatticeConnectivity(6, 4)
LatticeConnectivity{6,4}
              1 
              | 
        9 ──  5 ──  2 
        |     |     | 
 17 ── 13 ── 10 ──  6 ──  3 
  |     |     |     |     | 
 21 ── 18 ── 14 ── 11 ──  7 ──  4 
        |     |     |     |     | 
       22 ── 19 ── 15 ── 12 ──  8 
              |     |     | 
             23 ── 20 ── 16 
                    | 
                   24 


julia&gt; path = path_search(3, 24, connectivity)
6-element Vector{Int64}:
 24
 20
 16
 12
  7
  3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L951-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_adjacency_list" href="#Snowflurry.get_adjacency_list"><code>Snowflurry.get_adjacency_list</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_adjacency_list(connectivity::AbstractConnectivity)::Dict{Int,Vector{Int}}</code></pre><p>Given an object of type <code>AbstractConnectivity</code>, <code>get_adjacency_list</code> returns a <code>Dict</code> where each key is a qubit index. Every dictionary value is a <code>Vector</code> that lists all the qubits which are adjacent on the connectivity to the qubit key. Positions in <code>connectivity.excluded_positions</code> are not included as keys nor values.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(6)
LineConnectivity{6}
1──2──3──4──5──6


julia&gt; get_adjacency_list(connectivity)
Dict{Int64, Vector{Int64}} with 6 entries:
  5 =&gt; [4, 6]
  4 =&gt; [3, 5]
  6 =&gt; [5]
  2 =&gt; [1, 3]
  3 =&gt; [2, 4]
  1 =&gt; [2]

julia&gt; connectivity = LatticeConnectivity(3, 4)
LatticeConnectivity{3,4}
        1 
        | 
  9 ──  5 ──  2 
        |     | 
       10 ──  6 ──  3 
              |     | 
             11 ──  7 ──  4 
                    |     | 
                   12 ──  8 
  
julia&gt; get_adjacency_list(connectivity)
Dict{Int64, Vector{Int64}} with 12 entries:
  5  =&gt; [1, 10, 9, 2]
  12 =&gt; [7, 8]
  8  =&gt; [4, 12]
  1  =&gt; [5]
  6  =&gt; [2, 11, 10, 3]
  11 =&gt; [6, 7]
  9  =&gt; [5]
  3  =&gt; [7, 6]
  7  =&gt; [3, 12, 11, 4]
  4  =&gt; [8, 7]
  2  =&gt; [6, 5]
  10 =&gt; [5, 6]
</code></pre><div class="admonition is-info" id="Note-645166b29c9efac4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-645166b29c9efac4" title="Permalink"></a></header><div class="admonition-body"><p>The <code>get_adjacency_list</code> function cannot be used for <code>AllToAllConnectivity</code> since this type of connectivity places no upper bound on the number of qubits and all qubits connect to each other by definition. A finite list of adjacent qubits thus cannot be constructed. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L851-L910">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_qubits_distance" href="#Snowflurry.get_qubits_distance"><code>Snowflurry.get_qubits_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_qubits_distance(target_1::Int, target_2::Int, ::AbstractConnectivity)</code></pre><p>Find the length of the shortest path between target qubits in terms of the Manhattan distance. The function uses the Breadth-first search algorithm to determine the path length for any <code>connectivity::AbstractConnectivity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  connectivity = LineConnectivity(6)
LineConnectivity{6}
1──2──3──4──5──6


julia&gt; get_qubits_distance(2, 5, connectivity)
3

julia&gt; connectivity = LatticeConnectivity(6, 4)
LatticeConnectivity{6,4}
              1 
              | 
        9 ──  5 ──  2 
        |     |     | 
 17 ── 13 ── 10 ──  6 ──  3 
  |     |     |     |     | 
 21 ── 18 ── 14 ── 11 ──  7 ──  4 
        |     |     |     |     | 
       22 ── 19 ── 15 ── 12 ──  8 
              |     |     | 
             23 ── 20 ── 16 
                    | 
                   24 


julia&gt; get_qubits_distance(3, 24, connectivity)
5
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L431-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.is_native_instruction" href="#Snowflurry.is_native_instruction"><code>Snowflurry.is_native_instruction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_native_instruction(
    gate::Union{Gate},
    connectivity::Union{LineConnectivity,LatticeConnectivity},
    native_gates::Vector{DataType} = set_of_native_gates,
)::Bool</code></pre><p>Returns <code>true</code> if the <code>gate</code> is a native instruction for the <code>connectivity</code> and the list of possible <code>native_gates</code>. The native gates for the Anyon QPUs are used by default.</p><p>A native instruction is defined as an instruction that is in <code>native_gates</code> and that satisifies the <code>connectivity</code>. It does not check to determine if the <code>gate</code> is placed at the <code>excluded_positions</code> or <code>excluded_connections</code> of the <code>connectivity</code>. The gate must operate on less than three qubits.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(3)
LineConnectivity{3}
1──2──3


julia&gt; is_native_instruction(control_z(1, 2), connectivity)
true

julia&gt; is_native_instruction(control_z(1, 3), connectivity)
false

julia&gt; is_native_instruction(control_x(1, 2), connectivity)
false

julia&gt; is_native_instruction(control_x(1, 2), connectivity, [Snowflurry.ControlX])
true

julia&gt; is_native_instruction(toffoli(1, 2, 3), connectivity, [Snowflurry.Toffoli])
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L487-L526">source</a></section><section><div><pre><code class="language-julia hljs">is_native_instruction(
    readout::Readout,
    connectivity::Union{LineConnectivity,LatticeConnectivity},
    native_gates::Vector{DataType} = set_of_native_gates,
)::Bool</code></pre><p>Returns <code>true</code> if the <code>readout</code> satisfies the connectivity.</p><p>It does not check to determine if the <code>gate</code> is placed at the <code>excluded_positions</code> of the <code>connectivity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(3)
LineConnectivity{3}
1──2──3


julia&gt; is_native_instruction(readout(2, 2), connectivity)
true

julia&gt; is_native_instruction(readout(4, 4), connectivity)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L563-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.is_native_circuit" href="#Snowflurry.is_native_circuit"><code>Snowflurry.is_native_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_native_circuit(
    circuit::QuantumCircuit,
    connectivity::GeometricConnectivity,
    native_gates::Vector{DataType} = set_of_native_gates,
)::Tuple{Bool,String}</code></pre><p>Returns <code>(true, &quot;&quot;)</code> if the <code>circuit</code> only contains native instructions for the <code>connectivity</code> and the list of possible <code>native_gates</code>. It returns <code>(false, &quot;error_message&quot;)</code> otherwise. The native gates for the Anyon QPUs are used by default.</p><p>See <a href="qpu.html#Snowflurry.is_native_instruction"><code>is_native_instruction</code></a> for more details about the identification of native instructions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = LineConnectivity(3)
LineConnectivity{3}
1──2──3


julia&gt; native_circuit = QuantumCircuit(
           qubit_count = 3,
           instructions = [sigma_x(1), control_z(2, 3)]
       )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X───────
               
q[2]:───────*──
            |  
q[3]:───────Z──
               

julia&gt; is_native_circuit(native_circuit, connectivity)
(true, &quot;&quot;)

julia&gt; foreign_circuit = QuantumCircuit(
                  qubit_count = 3,
                  instructions = [sigma_x(1), control_x(2, 3)]
              )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X───────
               
q[2]:───────*──
            |  
q[3]:───────X──
               

julia&gt; is_native_circuit(foreign_circuit, connectivity)
(false, &quot;Instruction type Gate{Snowflurry.ControlX} with targets [2, 3] is not native on the connectivity&quot;)

julia&gt; is_native_circuit(
            foreign_circuit,
            connectivity,
            [Snowflurry.ControlX, Snowflurry.SigmaX]
        )
(true, &quot;&quot;)
</code></pre><p>The folowing circuit is not native because the Toffoli gate is applied to more than two qubits:</p><pre><code class="language-julia-repl hljs">julia&gt; foreign_circuit = QuantumCircuit(
           qubit_count = 3,
           instructions = [sigma_x(1), toffoli(1, 2, 3)]
       )
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────*──
            |  
q[2]:───────*──
            |  
q[3]:───────X──
               

julia&gt; is_native_circuit(
            foreign_circuit,
            connectivity,
            [Snowflurry.Toffoli, Snowflurry.SigmaX]
        )
(false, &quot;Instruction type Gate{Snowflurry.Toffoli} with targets [1, 2, 3] is not native on the connectivity&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L610-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.print_connectivity" href="#Snowflurry.print_connectivity"><code>Snowflurry.print_connectivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_connectivity(
    connectivity::LineConnectivity,
    ::Vector{Int} = Int[],
    io::IO = stdout
)</code></pre><p>Prints the <code>connectivity</code> to <code>io</code>.</p><p>Qubits with their index in <code>path</code> are highlighted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; print_connectivity(LineConnectivity(3))
1──2──3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L515-L532">source</a></section><section><div><pre><code class="language-julia hljs">print_connectivity(
    connectivity::LatticeConnectivity,
    path::Vector{Int} = Vector{Int}(),
    io::IO = stdout,
)</code></pre><p>Prints the <code>connectivity</code> to <code>io</code>.</p><p>Qubits with their index in <code>path</code> are highlighted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity=LatticeConnectivity(3,3);

julia&gt; path = path_search(1, 3, connectivity);

julia&gt; print_connectivity(connectivity, path)
     (1)
      | 
 7 ──(4)── 2 
      |    | 
     (8)──(5)──(3)
           |    | 
           9 ── 6 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L595-L622">source</a></section><section><div><pre><code class="language-julia hljs">print_connectivity(qpu::AbstractQPU, io::IO = stdout)</code></pre><p>Prints the qubit connectivity of the <code>qpu</code> to <code>io</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(
           host = &quot;http://example.anyonsys.com&quot;,
           user = &quot;test_user&quot;,
           access_token = &quot;not_a_real_access_token&quot;,
           project_id = &quot;test-project&quot;,
           realm = &quot;test-realm&quot;
       )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    test-project
   qubit_count:   6
   connectivity_type:  linear
   realm:         test-realm


julia&gt; print_connectivity(qpu)
1──2──3──4──5──6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/anyon.jl#L235-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_connectivity" href="#Snowflurry.get_connectivity"><code>Snowflurry.get_connectivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_connectivity(qpu::AbstractQPU)</code></pre><p>Returns the qubit connectivity of a <code>qpu</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu = AnyonYukonQPU(
       host = &quot;http://example.anyonsys.com&quot;,
       user = &quot;test_user&quot;,
       access_token = &quot;not_a_real_access_token&quot;,
       project_id = &quot;test-project&quot;,
       realm = &quot;test-realm&quot;
       )
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   project_id:    test-project
   qubit_count:   6
   connectivity_type:  linear
   realm:         test-realm


julia&gt; get_connectivity(qpu)
LineConnectivity{6}
1──2──3──4──5──6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/anyon/qpu_interface.jl#L485-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_connectivity_label" href="#Snowflurry.get_connectivity_label"><code>Snowflurry.get_connectivity_label</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_connectivity_label(connectivity::AbstractConnectivity)</code></pre><p>Returns the label of the connectivity.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_connectivity_label(LineConnectivity(6))
&quot;linear&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/085e62d64c88533b0303b5285eedc15e4005e003/src/core/connectivity.jl#L381-L392">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quantum_circuit.html">« Quantum Circuits</a><a class="docs-footer-nextpage" href="pauli_sim.html">Pauli Simulator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 24 October 2025 18:05">Friday 24 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
