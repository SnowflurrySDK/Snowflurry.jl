<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Toolkit · Snowflurry</title><meta name="title" content="Quantum Toolkit · Snowflurry"/><meta property="og:title" content="Quantum Toolkit · Snowflurry"/><meta property="twitter:title" content="Quantum Toolkit · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="Snowflurry logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="../tutorials/virtual_qpu.html">Virtual QPU</a></li><li><a class="tocitem" href="../tutorials/anyon_qpu.html">Real hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../tutorials/advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href="quantum_toolkit.html">Quantum Toolkit</a><ul class="internal"><li><a class="tocitem" href="#Basic-Quantum-Objects"><span>Basic Quantum Objects</span></a></li></ul></li><li><a class="tocitem" href="quantum_gates.html">Quantum Gates</a></li><li><a class="tocitem" href="quantum_circuit.html">Quantum Circuits</a></li><li><a class="tocitem" href="qpu.html">QPU</a></li><li><a class="tocitem" href="pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="quantum_toolkit.html">Quantum Toolkit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quantum_toolkit.html">Quantum Toolkit</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/library/quantum_toolkit.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h1><h2 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h2><p>There are three basic quantum objects in Snowflurry to simulate a quantum system. These objects are <code>Ket</code>, <code>Bra</code>, and <code>AbstractOperator</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.Ket" href="#Snowflurry.Ket"><code>Snowflurry.Ket</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>Ket</code> represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.   A <code>Ket</code> representing a system with a qubit count of <span>$n=2$</span> has <span>$2^n$</span> states.  By convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  Hence, a 2-qubit <code>Ket</code> has 4 complex-valued coefficients <span>$a_{ij}$</span>, each corresponding to state <span>$\left|ij\right\rangle$</span>, in the following order:</p><p class="math-container">\[\psi = \begin{bmatrix}
    a_{00}  \\
    a_{10}  \\
    a_{01}  \\
    a_{11}  \\
    \end{bmatrix}.\]</p><p><strong>Examples</strong></p><p>A Ket can be initialized by using a pre-built basis such as the <code>fock</code> basis. See <a href="quantum_toolkit.html#Snowflurry.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(2, 4)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im

</code></pre><p>Although NOT the preferred way, one can also directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Snowflurry

julia&gt; ψ = Ket([1.0; 0.0; 0.0; 0.0])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.Bra" href="#Snowflurry.Bra"><code>Snowflurry.Bra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing a Bra (i.e., a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; _ψ = Bra(ψ)
3-element Bra{ComplexF64}:
0.0 - 0.0im
1.0 - 0.0im
0.0 - 0.0im


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L138-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.DiagonalOperator" href="#Snowflurry.DiagonalOperator"><code>Snowflurry.DiagonalOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing a diagonal quantum <code>Operator</code> (i.e., a complex matrix of element type T, with non-zero elements all lying on the diagonal). The equivalent dense matrix would have size NxN.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DiagonalOperator([1.0,-1.0])
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im

julia&gt; z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])
(4,4)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 1.0im    .    .    .
.    1.0 + 0.0im    .    .
.    .    1.0 + 0.0im    .
.    .    .    0.0 - 1.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L419-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.AntiDiagonalOperator" href="#Snowflurry.AntiDiagonalOperator"><code>Snowflurry.AntiDiagonalOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AntiDiagonalOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing a anti-diagonal quantum <code>Operator</code> (i.e., a complex matrix of element type T, with non-zero elements all lying on the cross-diagonal). The equivalent dense matrix would have size NxN.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AntiDiagonalOperator([1, 2])
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    2.0 + 0.0im    .
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L473-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.DenseOperator" href="#Snowflurry.DenseOperator"><code>Snowflurry.DenseOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing a quantum operator with a full (dense) matrix representation of size NxN and containing elements of type T.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DenseOperator([1.0 0.0;0.0 -1.0])
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = rotation(π/2, -π/4)  
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im
-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L247-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SwapLikeOperator" href="#Snowflurry.SwapLikeOperator"><code>Snowflurry.SwapLikeOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SwapLikeOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing a quantum operator performing a &quot;swap&quot; operation, with element type T. A <code>phase</code> value is applied to the swapped qubit coefficients. This operator is always of size 4x4.</p><p>For example, the iswap <code>Operator</code> can be built using a <code>phase=0.0 + 1.0im</code> by calling:</p><pre><code class="language-julia-repl hljs">julia&gt; SwapLikeOperator(0.0 + 1.0im)
(4, 4)-element Snowflurry.SwapLikeOperator:
Underlying data ComplexF64:
Equivalent DenseOperator:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L310-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.IdentityOperator" href="#Snowflurry.IdentityOperator"><code>Snowflurry.IdentityOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdentityOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing the identity quantum operator, with element type T. This operator is always of size 2x2.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; IdentityOperator()
(2, 2)-element Snowflurry.IdentityOperator:
Underlying data ComplexF64:
Equivalent DenseOperator:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L363-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.SparseOperator" href="#Snowflurry.SparseOperator"><code>Snowflurry.SparseOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparseOperator{N,T&lt;:Complex}&lt;:AbstractOperator</code></pre><p>A structure representing a quantum operator with a sparse (CSR) matrix representation, with element type T. The equivalent dense matrix would have size NxN.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>apply_operator()</code> method is not implemented for this operator type. Try using <code>DenseOperator</code> instead.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = SparseOperator([-1.0 1.0;0.0 -1.0])
(2, 2)-element Snowflurry.SparseOperator:
Underlying data ComplexF64:
 -1.0 + 0.0im   1.0 + 0.0im
       ⋅       -1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L189-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.Readout" href="#Snowflurry.Readout"><code>Snowflurry.Readout</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Readout &lt;: AbstractInstruction</code></pre><p><code>Readout</code> is an implementation of an <code>AbstractInstruction</code> that specifies  an explicit measurement on a particular qubit, and the destination bit in  the classical result registry (classical bit). It is built using the <code>readout(qubit::Int, bit::Int)</code> helper function, where  the first argument is the target qubit, and the second is the destination classical bit. Measurements are always performed in the <span>$Z$</span> basis (also known as the computational basis).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = readout(1, 2)
Explicit Readout object:
   connected_qubit: 1 
   destination_bit: 2 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/readout.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.readout" href="#Snowflurry.readout"><code>Snowflurry.readout</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readout(qubit::Int, bit::Int)</code></pre><p>Return a <code>Readout</code> <code>AbstractInstruction</code>, which performs a  readout on the target <code>qubit</code>, and places the result in the destination <code>bit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/readout.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L532-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.is_hermitian" href="#Snowflurry.is_hermitian"><code>Snowflurry.is_hermitian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_hermitian(A::AbstractOperator)</code></pre><p>Determine if Operator <code>A</code> is Hermitian (i.e., self-adjoint).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; is_hermitian(Y)
true

julia&gt; P = sigma_p()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    0.0 + 0.0im    .


julia&gt; is_hermitian(P)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L548-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractOperator}" href="#Base.exp-Tuple{AbstractOperator}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractOperator)</code></pre><p>Compute the matrix exponential of <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; x_rotation_90_deg = exp(-im*π/4*X)
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im
0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L713-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractOperator, Int64, Int64}" href="#Base.getindex-Tuple{AbstractOperator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>getindex(A::AbstractOperator, i::Integer, j::Integer)</p><p>Access the element at row i and column j in the matrix corresponding to <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; Y[1,1]
0.0 + 0.0im

julia&gt; Y[1,2]
0.0 - 1.0im

julia&gt; Y[2,1]
0.0 + 1.0im

julia&gt; Y[2,2]
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L388-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.expected_value-Tuple{AbstractOperator, Ket}" href="#Snowflurry.expected_value-Tuple{AbstractOperator, Ket}"><code>Snowflurry.expected_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expected_value(A::AbstractOperator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L799-L822">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse(x::AbstractOperator)</code></pre><p>Returns a SparseOperator representation of x.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = sparse(sigma_z())
(2, 2)-element Snowflurry.SparseOperator:
Underlying data ComplexF64:
 1.0 + 0.0im        ⋅     
      ⋅       -1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L230-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigen(A::AbstractOperator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L742-L770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tr(A::AbstractOperator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L776-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="quantum_toolkit.html#Snowflurry.Ket"><code>Kets</code></a> or two  <a href="quantum_toolkit.html#Snowflurry.DenseOperator"><code>DenseOperator</code></a> , <a href="quantum_toolkit.html#Snowflurry.DiagonalOperator"><code>DiagonalOperator</code></a>, <a href="quantum_toolkit.html#Snowflurry.AntiDiagonalOperator"><code>AntiDiagonalOperator</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0])
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L841-L881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.MultiBodySystem" href="#Snowflurry.MultiBodySystem"><code>Snowflurry.MultiBodySystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L892-L896">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.commute" href="#Snowflurry.commute"><code>Snowflurry.commute</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; σ_y = sigma_y()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; commute(σ_x, σ_y)
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
0.0 + 2.0im    .
.    0.0 - 2.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1628-L1654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.anticommute" href="#Snowflurry.anticommute"><code>Snowflurry.anticommute</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">anticommute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; anticommute(σ_x, σ_x)
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
2.0 + 0.0im    .
.    2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1658-L1677">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 2., 4.])
3-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
4.0 + 0.0im

julia&gt; normalize!(ψ)
3-element Ket{ComplexF64}:
0.2182178902359924 + 0.0im
0.4364357804719848 + 0.0im
0.8728715609439696 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1426-L1445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real" href="#Snowflurry.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real"><code>Snowflurry.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(x::Ket{Complex{T}},
    [target_bodies::Vector{U},
    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}
    where {T&lt;:Real, U&lt;:Integer}</code></pre><p>Returns a vector listing the measurement probabilities of the <code>target_bodies</code> of <code>Ket</code> <code>x</code>.</p><p>The Hilbert space size per body can be specified by providing a <code>Vector</code> of <code>Integer</code> for the <code>hspace_size_per_body</code> argument. The <code>Vector</code> must specify the Hilbert space size for each body. If the space size is uniform, a single <code>Integer</code> can be given instead. If only <code>x</code> is provided, the probabilities are provided for all the bodies.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>Ket</code>, the probabilities are listed for <span>$\left|00\right\rangle$</span>,  <span>$\left|10\right\rangle$</span>, <span>$\left|01\right\rangle$</span>, and <span>$\left|11\right\rangle$</span>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  <span>$\left|10\right\rangle$</span> has qubit 1 in state <span>$\left|1\right\rangle$</span> and qubit 2 in state <span>$\left|0\right\rangle$</span></p></div></div><p><strong>Examples</strong></p><p>The following example constructs a <code>Ket</code>, where the probability of measuring  <span>$\left|00\right\rangle$</span> is 50% and the probability of measuring <span>$\left|01\right\rangle$</span> is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ = 1/sqrt(2) * Ket([1, 0, 1, 0])
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im
0.0 + 0.0im


julia&gt; get_measurement_probabilities(ψ)
4-element Vector{Float64}:
 0.4999999999999999
 0.0
 0.4999999999999999
 0.0
</code></pre><p>For the same <code>Ket</code>, the probability of measuring qubit 2 and finding 0 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(ψ, target_qubit)
2-element Vector{Float64}:
 0.9999999999999998
 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1452-L1504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.ket2dm" href="#Snowflurry.ket2dm"><code>Snowflurry.ket2dm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ket2dm(ψ::Ket)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1681-L1685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.fock_dm" href="#Snowflurry.fock_dm"><code>Snowflurry.fock_dm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fock_dm(i::Int64, hspace_size::Int64)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dm = fock_dm(0, 2)
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1690-L1705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.wigner" href="#Snowflurry.wigner"><code>Snowflurry.wigner</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wigner(ρ::AbstractOperator, p::Real, q::Real)</code></pre><p>Computes the Wigner function of the density matrix <code>ρ</code> at the point (<code>p</code>,<code>q</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; alpha = 0.25;

julia&gt; hspace_size = 8;

julia&gt; Ψ = coherent(alpha, hspace_size);

julia&gt; prob = wigner(ket2dm(Ψ), 0, 0);

julia&gt; @printf &quot;prob: %.6f&quot; prob
prob: 0.561815</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1708-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.moyal" href="#Snowflurry.moyal"><code>Snowflurry.moyal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Fock basis states numbering starts at 0.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1742-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.genlaguerre" href="#Snowflurry.genlaguerre"><code>Snowflurry.genlaguerre</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1766-L1771">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_embed_operator" href="#Snowflurry.get_embed_operator"><code>Snowflurry.get_embed_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = MultiBodySystem(3, 2)
Snowflurry.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = sigma_x()
(2,2)-element Snowflurry.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; X_1 = get_embed_operator(x, 1, system)
(8, 8)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L914-L945">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_qubits-Tuple{AbstractOperator}" href="#Snowflurry.get_num_qubits-Tuple{AbstractOperator}"><code>Snowflurry.get_num_qubits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::AbstractOperator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 
                          0. 0.])
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1120-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_qubits-Tuple{Union{Bra, Ket}}" href="#Snowflurry.get_num_qubits-Tuple{Union{Bra, Ket}}"><code>Snowflurry.get_num_qubits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1155-L1173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_bodies" href="#Snowflurry.get_num_bodies"><code>Snowflurry.get_num_bodies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with an <code>Operator</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 0.
                          0. 0. 0.
                          0. 0. 0.])
(3, 3)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_bodies(ρ, 3)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1187-L1207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_bodies" href="#Snowflurry.get_num_bodies"><code>Snowflurry.get_num_bodies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with a <code>Ket</code> or a <code>Bra</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])
9-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_bodies(ψ, 3)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1225-L1249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.fock" href="#Snowflurry.fock"><code>Snowflurry.fock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fock(i, hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>i</code>th Fock basis of a Hilbert space with size <code>hspace_size</code> as a Ket.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Fock basis states numbering starts at 0.</p></div></div><p>The Ket contains values of type <code>T</code>, which by default is ComplexF64.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(0, 3)
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3, ComplexF32) # specifying a type other than ComplexF64
3-element Ket{ComplexF32}:
0.0f0 + 0.0f0im
1.0f0 + 0.0f0im
0.0f0 + 0.0f0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1263-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.spin_up" href="#Snowflurry.spin_up"><code>Snowflurry.spin_up</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spin_up(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-up state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_up()
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1304-L1320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.spin_down" href="#Snowflurry.spin_down"><code>Snowflurry.spin_down</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spin_down(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-down state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_down()
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1323-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.create" href="#Snowflurry.create"><code>Snowflurry.create</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1342-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.destroy" href="#Snowflurry.destroy"><code>Snowflurry.destroy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">destroy(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1355-L1359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.number_op" href="#Snowflurry.number_op"><code>Snowflurry.number_op</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_op(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1368-L1372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.coherent" href="#Snowflurry.coherent"><code>Snowflurry.coherent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = coherent(2.0, 20)
20-element Ket{ComplexF64}:
0.1353352832366127 + 0.0im
0.2706705664732254 + 0.0im
0.3827859860416437 + 0.0im
0.44200318416631873 + 0.0im
0.44200318416631873 + 0.0im
0.3953396664268989 + 0.0im
0.3227934859426707 + 0.0im
0.24400893961026582 + 0.0im
0.17254037586855772 + 0.0im
0.11502691724570517 + 0.0im
0.07274941014482605 + 0.0im
0.043869544940011405 + 0.0im
0.025328093580341972 + 0.0im
0.014049498479026656 + 0.0im
0.007509772823502764 + 0.0im
0.003878030010563634 + 0.0im
0.001939015005281817 + 0.0im
0.000940560432521708 + 0.0im
0.0004433844399679012 + 0.0im
0.00020343873336404819 + 0.0im


julia&gt; expected_value(number_op(20), ψ)
3.99999979364864 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1381-L1416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.compare_kets" href="#Snowflurry.compare_kets"><code>Snowflurry.compare_kets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_kets(ψ_0::Ket,ψ_1::Ket)</code></pre><p>Checks for equivalence allowing for a global phase difference between two input kets.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([1., 2., 3., 4.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
3.0 + 0.0im
4.0 + 0.0im


julia&gt; δ = π/3 # phase offset
1.0471975511965976

julia&gt; ψ_1 = exp(im * δ) * ψ_0
4-element Ket{ComplexF64}:
0.5000000000000001 + 0.8660254037844386im
1.0000000000000002 + 1.7320508075688772im
1.5000000000000004 + 2.598076211353316im
2.0000000000000004 + 3.4641016151377544im


julia&gt; compare_kets(ψ_0, ψ_1)
true

julia&gt; apply_instruction!(ψ_1, sigma_x(1))
4-element Ket{ComplexF64}:
1.5000000000000004 + 2.598076211353316im
2.0000000000000004 + 3.4641016151377544im
0.5000000000000001 + 0.8660254037844386im
1.0000000000000002 + 1.7320508075688772im


julia&gt; compare_kets(ψ_0, ψ_1) # no longer equivalent after SigmaX gate
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L84-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.compare_operators" href="#Snowflurry.compare_operators"><code>Snowflurry.compare_operators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_operators(H_0::AbstractOperator, H_1::AbstractOperator)::Bool</code></pre><p>Checks for equivalence allowing for a global phase difference between two input operators.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H_0 = z_90()
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
0.7071067811865476 - 0.7071067811865475im    .
.    0.7071067811865476 + 0.7071067811865475im


julia&gt; H_1 = phase_shift(pi / 2)
(2,2)-element Snowflurry.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    6.123233995736766e-17 + 1.0im


julia&gt; compare_operators(H_0, H_1)
true

julia&gt; H_1 *= sigma_x()
(2, 2)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    1.0 + 0.0im
6.123233995736766e-17 + 1.0im    0.0 + 0.0im


julia&gt; compare_operators(H_0, H_1) # no longer equivalent after applying sigma x
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/3052d7d6f5929433f263043b118e233af3c4a1e6/src/core/qobj.jl#L1806-L1842">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/advanced/async_jobs.html">« Asynchronous Jobs</a><a class="docs-footer-nextpage" href="quantum_gates.html">Quantum Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Thursday 29 August 2024 17:54">Thursday 29 August 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
